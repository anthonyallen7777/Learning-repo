React - client-side javascript library

why react?
- ui state becomes difficult to manage with vanilla js
- active community

--------

javascript refresher
VARIABLES

let -variable that is variable
const - something that is assigned once and never changed

----
EXPORT & IMPORT

const person = {
	name: 'Jeff'
}

 export default person
----
export const clean = () => {...}

export const baseData = 10;
----
import person from './person.js'
import prs from './person.js'

import { baseData } from './utility.js'
import { clean } from: './utility.js'

Default export:
import person from './person.js'
import prs from './person.js'

Named export:
import { smth } from './utility.js'
import {smth as Smth} from './utility.js'
import * as bundled from './utility.js'

--------
CLASSES:
- blueprints for objects
- can have properties and methods
- methods: functions attached to classes
- properties: variables attached to classes
- supports inheritance

class Person {
	name = 'Max' #Property
	call = () => {...} #Method
}

const myPerson = new Person()
myPerson.call()
console.log(myPerson.name)

class Person extends Master

----
class Human {
	gender = 'male';

	printGender = () => {
	console.log(this.gender);
	}
}
class Person extends Human {
	name = 'Max';
	gender = 'female';

	printMyName = () => {
	console.log(this.name);
	}
}

const person = new Person();
person.printMyName();
person.printGender();
----

PROPERTIES

ES6
constructor() {
	this.myProperty = 'value'
}

ES7
myProperty = 'value'

----

METHODS

ES6
myMethod() {...}

ES7
myMethod = () => {...}


--------
OPERATORS:
- ...
- Spread: used to split up array elements OR object properties
const newArray = [...oldArray, 1, 2]
const newObject = {...oldObject, newProp:5}

- Rest: used to merge a list of function arguments into an array
function sortArgs(...args) {
	return args.sort()
}

----

const numbers = [1,2,3];
const newNumbers = [...numbers, 4];

console.log(newNumbers);

const person = {
	name: 'Max'
};

const newPersons = {
	...person,
	mood: 'happy'
}

console.log(newPerson);

const filter = (...args) => {
	return args.filter(el => el === 1);
}

console.log(filter(1, 2, 3));
--------
DESTRUCTURING
- Easily extract array elements or object properties and store them in variables
- Array Destructuring:
[a, b] = ['Hello', 'Max']
console.log(a) // Hello
console.log(b) // Max

- Object Destructuring:
{name} = {name:'Max', mood:'happy'}
console.log(name) // Max
console.log(mood) // undefined

----
const number = [1, 2, 3];
[num1, num2] = numbers;
console.log(num1, num2); // 1 2

[num1, , num3] = numbers;
console.log(num1, num3); // 1 3
--------
REFERENCE AND PRIMITIVE TYPES

Primitive types:
- numbers, strings, booleans
- they copy the values

const number = 1; //primitive type
const num2 = number; //copies the values

console.log(num2);

Reference types:
- objects, arrays
- whereas primitive types are stored in memory, reference types store a pointer to that place in memory

----
REFERENCE

const person = {
	name: 'Max'
}

const secondPerson = person;

person.name = 'Manu';

console.log(secondPerson);

----
REAL COPY

const person = {
	name: 'Max'
}

const secondPerson = {
	...person
};

person.name = 'Manu';

console.log(secondPerson);
--------
ARRAY FUNCTIONS

const numbers = [1, 2, 3];

const doubleNumArray = numbers.map((num) => {
	return num * 2;
});

console.log(numbers);
console.log(doubleNumArray);
--------


BASE SYNTAX
--------

linting - tool reminds you if you are writing suboptimal code

npm or yarn - dependency management

bundler(ex: webpack) - write module code and split up over multiple files. This code gets bundled into only a couple of files when we ship it
- helps import css into js files

babel + presets - compile code to run on as many browsers as possible

development server - webserver running on our machine to test code

register service worker: pre-cache script files

react component always has to render some html code to the dom

JSX:
- code used to write html but is not actual html
- etiquette says to nest everything in one root

In it's simplest form a Component is just a function that returns some JSX (some html)

PROPS
- props (properties) are the attributes you add onto your component
- they're set and passed from outside

when using class-based components, it's this.props

class PErson extends Component {
	render() {
	return <p>My name is {this.props}</p>;
	}
}

State:
- change your component at runtime
- state is managed from inside the component
- should be used with care (can make app unpredictable and hard to manage as it grows)
- updating state also updates props

Stateless Components (dumb components OR presentational components)
- have no internal state management
It is good practice to use stateless components as much as possible (makes app easier to maintain and manage)

Stateful Components (smart components OR container components)
- have internal state management
- only use state in a few select components

Method:
- a function of a class

Dont add function brackets to method in onclick b/c will immediately execute the function once react renders the component to the dom. Instead pass a Reference

// v THIS CAN BE INEFFICIENT WHEN SCALING PROJECT
onClick={() => this.switchNameHandler('Jeff!!')}

 MAY WANT TO USE v
 click={this.switchNameHandler.bind(this, "Jefferey!")}>

----
testMethod = () => {
	//using this type of method ensures that using 'this' always refers to the current class we're in

	this.setState({
	someState: 'some value'
	})    
}

Hook
- can manage state in functional components

--------
LISTS & CONDITIONALS

output content conditionally using javascript with ternary expression or better yet create variables

map operation - use on arrays to map objects or strings, etc into array of jsx elements and react will out these elements out and render to screen

add key to let react efficient update
--------
STYLING

Radium package
- lets us use inline styles with pseudo selectors and media queries
- wrap entire app in root component with StyleRoot so you can access radium functionality

export default Radium(App);
- this called a higher order component
- it's just a component wrapping another component adding extra functionality

Media queries can be used to check many things, such as:
- width and height of the viewport
- width and height of the device
- orientation (is the tablet/phone in landscape or portrait mode?)
- resolution

----

Styled components library
- making styled components very simple

backticks templates
- vanilla javascript feature
- used to define template literals
	- template literals are used to make strings easier
	- can interpolate any kind of expression in the template literal
	- can be multi-line

const Button = styled.button``
- function call that takes what text you pass it as styling for the button

----

npm run eject
- will eject from the under the hood configuration where you dont have access to the underlying web packed confile file, etc and gives you access

----
css modules feature

config/webpack.config.dev.js
config/webpack.config.prod.js

modules: true,
localIdentName: '[name]__[local]__[hash:base64:5]'

app.js

import classes from './App.css'

<div className={classes.App}>

^^^^^^
This css modules feature detects the import from the css file and understand not to just import the css as it is and instead look into the css and transforms every class name in a random unique class and returns a map mapped to the class names we choose
----
react-scripts 2 and higher you must vv

you can save the eject step and just

import classes from './Person.module.css';
rename to Person.modules.css
--------
DEBUGGING
always check line number
use dev tool debugger
- source maps
- breakpoints and steps (in and outs)

use the React extension to get insight into app

----

StrictMode
- a tool for highlighting potential problems in an application
 - Strict mode checks are run in development mode only; they do not impact the production build

StrictMode currently helps with:
- Identifying components with unsafe lifecycles
- Warning about legacy string ref API usage
- Warning about deprecated findDOMNode usage
- Detecting unexpected side effects
- Detecting legacy context API
- Ensuring reusable state

----

ErrorBoundary component
- only use for cases that you know might fail and you know you can't control

componentDidCatch
- will be executed whenever a component we wrap with the ErrorBoundary throw an error
--------
COMPONENT DEEP DIVE

the render method should be lean and not contain too much jsx

containers
- manages the state
- manipulates the state

----
Stateful vs Stateless

stateless (dumb components)
- historically have always been functional components
- since React 16.8 functional components can manage state with useState hook

by splitting app into container components and dumb components you can keep your app manageable

----
(Use if you need to manage State or access to Lifecycle Hooks and don't want to use React Hooks)

Class-based
class XY extends Component
- access to state
- lifecycle hooks
access state and props via "this"
this.state.XY & this.props.XY
----
(Use in all other Cases)
Functional
const XY = prop => {...}
- access to state(useState())
X (NOT SUPPORTED YET) lifecycle hooks
props.XY
----

Component Lifecycle Methods or Component Lifecycle Hook
- Only available in Class-based Components

constructor()
getDerivedStateFromProps()
getSnapshotBeforeUpdate()
componentDidCatch()
componentWillUnmount()
shouldComponentUpdate()
componentDidUpdate()
componentDidMount()
render()

(Lifecycle Hooks have nothing to do with React Hooks)

Component Lifecycle - CREATION

constructor(props)
- Default ES6 class Feature
- Call super(props)
 - basically executes the contructor of the component you're extending (important so that everything get initialized correctly)
- DO: Set up State
- DONT: Cause Side-Effects
 - by side-effect it means sending http request, storing something in local browser storage, or sending analytics to google
 - this will impact performance and cause unnecessary re-renders

					|
					v
getDerivedStateFromProps(props,state)
- when ever your props change or class-based component you can sync your state to them
- DO: Sync state
- DONT: Cause Side-Effects

					|
					v
render()
- Prepare & Structure JSX code
- DO: Layout JSX and render html code
- DONT:
 - send http request or set any timeouts
 - nothing that will block the rendering process

					|
					v
Render Child Components

					|
					v
componentDidMount()
- DO: Cause Side-Effects
 - here you can make http requests
- DONT: Update State (triggers re-render)
 - dont update state here unless it's in a then block of a promise
 - dont call set state in here synchronously
----
Component Lifecycle - UPDATE

getDerivedStateFromProps(props,state)
- used to initialize the state of a component that updates based on props you're getting
- maybe some form control that gets external properties and want to interally handle user input
- DO: Sync State to Props
- DONT: Cause Side-Effects

					|
					v
shouldComponentUpdate(nextProps, nextState)
- May cancel updating process
- DO: Decide whether to Continue or Not
- DONT: Cause Side-Effects
- For performance optimization
- use carefully
- does a shallow comparison
 - as in for example arrays it compares the pointers not what the array is pointing to

					|
					v
render()
- Prepare & Structor JSX Code

					|
					v
Update Child Component Props

					|
					v
getSnapshotBeforeUpdate(prevProps, prevState)
 - use to save some data before the update and use it in the update
- DO: Last-minute DOM operations
 - like getting the current scrolling position of user
- DONT: Cause Side-Effects

					|
					v
componentDidUpdate()
- Most commonly used component
- DO: Cause Side-Effects
 - make http requests
- DONT: Update State (triggers re-render)
- don't update the state synchronously
- careful not to get caught in infinite loop here (ex when making http request and updating component)
----

Most important hooks
componentDidMount()
- typically fetching data from a server
componentDidUpdate()
- typically fetching data from a server
shouldComponentUpdate()
- for performance improvements

----

useEffect
- second most important next to useState
- basically combines the functionality or the use cases of all class-based lifecycle hook in one react hook
- not a lifecycle hook
- this is a React hook so you can add it into components
- can send http requests
- runs when component is created as well
takes a function that will run every render cycle


cleanup work
componentWillUnmount
- code run right before component is removed

useEffect cleanup
- can be ran when the component get destroyed (empty argument [] , or on every update (no argument), or pass an array that list all the data to watch and only when that data changes does it run the function useEffect then run the cleanup function

below we are cleaning up when the component is destroyed (an empyty array is passed)

useEffect(() => {
	console.log('[test.js useEffect');

	//this function is run before the main useEffect function runs but after the (first) render cycle
	return () => {
		console.log('[test.js] cleanup work in useEffect')
	}
}, []);

----

React.memo();

memoization
- technique where React will store a snapshot of this component and only if its input changes, it will re-render it and otherwise if its input do not change react will give back the stored component
- great way of getting optimization for functional components

----

PureComponent
- just a normal component that already implements shouldComponentUpdate with a complete props check that check for any changes for any prop in that component

----

How React Updates the (Real) DOM (the DOM in the browser)

render() is called
- render is like a suggestion of what the HTML should look like in the end, it can show what is already displayed
- this also applies to functional components and the JSX returned there, NOT just class-based components
- use shouldComponentUpdate() to prevent unnecessary render calls

Old Virtual DOM
<div>...<div>
- Faster than the "real" DOM
- it's simply a DOM representation in Javascript

Re-render Virtual DOM
<div>...<div>
- created when the render() method is called
- render() doesn't immediately update the "real" DOM!

It compares the old virtual DOM to the new one and checks if there are any differences
- if there are differences it reaches to the real DOM and updates it and only changes the places where difference were detected
- if no differences were found, then it doesn't touch the real DOM

accessing the DOM is really slow, it's something you want to do as little as possible

----

adjacent jsx elements

return [
	<p key='i1'>Hello</p>,
	<p key='i2'>I Am Adjacent</p>,
	<input key='i3' type="text"/>
];

Auxillary components
- used as a wrapper in cases where you want adjacentelements without extra DOM element being rendered
- HOC (higher order component)

aux.js
const aux = props => props.children;
export default aux;

props.children
- simply outputs whatever gets entered between the opening and closing tag this component

React.Fragment
- does the same thing as the Aux component

----

HOC
- Higher Order Component
- component that wraps other components that adds something to it (styling, additional HTML structure, or some logic)

----

passing unknown props

return props => (
    <div className={className}>
        <WrappedComponent {...props} />
    </div>
);
- the spread operator pull out all the properties that  are inside of this props object and distributes them as new key-value pairs on the wrapped component

----
SUPER IMPORTANT STUFF RIGHT HERE
setting state correctly

setState does not immediately trigger an update of the state of the component in a re-render cycle, instead it is scheduled by React and React will perform the state update and re-render when it has the resources

this.setState((prevState, props) => {
  return {
    persons: persons,
    changeCounter: prevState.changeCounter + 1
  };
});

----
propTypes

npm install --save prop-types

Person.propTypes = {
    click: PropTypes.func,
    name: PropTypes.string,
    age: PropTypes.number,
    changed: PropTypes.func
};
- special javascript property that can be added to any javascript component object that React will watch out for in dev mode and give a warning if you pass in incorrect props

this is especially helpful when you distribute components as a package to other devs or when working with a team
----
using refs in class-based components
(references)

ref
- just like key is a special property that is understood by React


1st approach
componentDidMount() {
    this.inputElement.focus();
}

<input
ref={(inputEl) => {this.inputElement = inputEl}}
/>
- this gives you a reference to the element you've placed it on

2nd approach (more modern approach)
constructor() {
	this.inputElementRef = React.createRef();
}

componentDidMount() {
    this.inputElementRef.current.focus();
}

<input
ref={(inputEl) => {this.inputElement = inputEl}}
/>
----
understand problems with prop chains

Context
- helps handle cases where you need certain data in multiple components and you dont want to pass that state across multiple layers
- object, array, string, or number that can be passed between React components without using props

contextType

auth-context.js
const authContext = React.createContext({
    authenticated: false,
    login: () => {}
});

app.js
<AuthContext.Provider value={{
	authenticated: this.state.authenticated,
	login: this.loginHandler
}}>

CONTEXTTYPE

import AuthContext from '../../../context/auth-context';

static contextType = AuthContext;

console.log(this.context.authenticated);

OR

USECONTEXT

import React, { useContext } from "react";

const authContext = useContext(AuthContext);

console.log(authContext.authenticated);
--------

LEARN PROJECT
----

Planning a React App
Component Tree/Component Structure

Application State(Data)

Components vs Containers

----

class componentName extends Component {
	
}

^^^^ we can still use this as functional (dumb) component if we omit the state. It doesn't just become a stateful component just because we use class instead of a function form

inside a class you access props with this.props

font-size: 1.2rem; //scales the font-size based on the font-size the user selected

{salad: 1, bacon: 1, cheese: 2, meat: 2}
					|
					|
					v
	['salad', 'bacon', 'cheese', 'meat']
					|
					|
					v
[['salad', 1], ['bacon', 1], ['cheese', 2], ['meat', 2]]


reduce((arr, el) => {
	return arr.concat(el) // [] + [] = []
}, []);

transform an array into something else

----

// Must be in this format to reference this.setState({});

func = () => {
	this.setState({});
} 

----

z-index
- the higher the value the closer it is to the you
- the lower the value the further away it is from the you

----

Mobile first way
- base classes are for mobile devices then add media queries to make it look good on bigger devices

----

<Modal>
	<OrderSummary/>
</Modal>

- The wrapping element (Modal) controls the updating of the wrapped element (OrderSummary)

--------

HTTP

----

Ajax

react
- library for front-end
- the code running in the browser

http requests in React (typically)
- decoupling
- there is a strong differentiation between your frontend, react app, and you backend, server

S E R V E R 
|	^	|
X	| (JSON Data)
|	|	|
v	|	v
REACT  APP

Server is typically a RESTful API
- just exposing some API endpoints to which you can send requests to get or send data from your standalone react app

Two way to send Ajax request
- XML HTTP request (XMLHttpRequest)
 - you can use this to construct your own Ajax request and send them to a specific url and handle the response
- Axios
 - a third party javascript library
 - can be used in any javascript code

componentDidMount()
- this where we should fetch data (HTTP requests)
- but NOT for updating state (because it triggers a re-render)

.then();
- takes a function a input and the function is executed when the promise resolves (once the data from backend is here)


real app you could send some query parameter to backend to restrict the amount of data you want
 - pagination (basically)


() => this.postSelectedHandler(post.id)
- reason to use this to to be able to pass an argument to the function

componentDidUpdate()
- here we can also fetch data (http request)

GET
200 - Successful

POST
201 - Successful

DELETE
200 - Successful

----

Interceptors
- functions defined globally which will we executed every request leaving app and every response returning into app
- this useful for setting headers (authorization headers), or logging responses, or handling errors globally

index.js
axios.interceptors.request.use(request => {
  console.log(request);
  // Edit request config
  return request;
}, error => {
  console.log(error);
  return Promise.reject(error);
});

axios.interceptors.response.use(response => {
  console.log(response);
  return response;
}, error => {
  console.log(error);
  return Promise.reject(error);
})

----

setting a default global configuration for axios

axios.defaults.baseURL = 'https://jsonplaceholder.typicode.com';
axios.defaults.headers.common['Authorization'] = 'AUTH TOKEN';
axios.defaults.headers.post['Context-Type'] = 'application/json';

axios instances
- give you flexibility
- allows you to control in detail which part of your app you want to use which default settings
 
root axios.js
const instance = axios.create({
    baseURL: 'https://jsonplaceholder.typicode.com',
});

instance.defaults.headers.common['Authorization'] = 'AUTH TOKEN FROM INSTANCE';

blog.js
import axios from '../../axios';


http requests in Multi-page application in React
- a page submits a form
- that sends a request to the backend (with potentially new react code)
- you get back new html page with (potentially new react code)

--------

FIREBASE

----
database

using realtime database
- we wont connect directly to the database we just send http request and firebase does the mapping of the http endpoints to the database

ONLY IN THE DEV ENVIRONMENT SHOULD THE READ AND WRITE RULES BE SET TO TRUE


Firebase POST
- when posting each list item gets a unique ID assigned by firebase automatically

axios.post('/orders.json', order)
.then(res => {
    console.log(res);
})
.catch(err => {
    console.log(err);
});

----

pass props and error handling
const withErrorHandler = (WrappedComponent, axios) => {
    return (props) => {
        return (
        <Aux>
            <Modal show>
                Something didn't work!
            </Modal>
            <WrappedComponent {...props} />
        </Aux>
        );
    };
};

//prevent memory leaks by ejecting interceptors
//because this component will be run on multiple other components (it's a HOC component)
//we need to make sure it doesn't create lots of interceptors that sit around in memory
componentWillUnmount() {
    // console.log('Will Unmount', this.requestInterceptor, this.responseInterceptor);
    axios.interceptors.request.eject(this.requestInterceptor);
    axios.interceptors.response.eject(this.responseInterceptor);
}

--------

ROUTING
- Routing is about being able to show different pages to the user
- routing is about parsing paths, so the path after our domain and showing the appropriate JSX or component code
- load conditional JSX or component code for different paths
- use a router package so we dont have to determine which path the user is on on our own

					Single Page
					(HTML File)

/ 		/blog		/blog/post/1	/users	/account	orders
		(Not real Files but re-rendered Single Page!)

					Router Package
Parses URL /Path -> Read Config -> Render / Load appropriate JSX / Component

- we don't actually have different files but we just re-render part of the single page or the entire page depending on which path the user navigated to

npm i react-router react-router-dom
react-router
react-router-dom
- defacto standard packages for routing in React

As long as you're user is navigating around you rarely want to reload, you want to just re-render the page in the parts where it needs to be rendered so it looks a reload
- this is super IMPORTANT because not reloading when navigating routes makes it so our state is saved

absolute path
- an absolute path is always appended to your domain

relative path
- 


Passing parameters

<Link
to={'/' + post.id}
key={post.id}>
    <Post
    title={post.title}
    author={post.author}
    clicked={() => this.postSelectedHandler(post.id)} />
</Link> );

<Route path="/:id" exact element={<FullPost />} />


<Switch> is pretty much <Routes> in react-router-dom v6

----

Navigation guard
- typical used when you dont know if a user is authenticated or not and there are some routes in your app you only want to allow the user to visit if they are authenticated

----
404

<Route path="*" element={<h1>Not Found.</h1>} />
- always last

----

lazy-loading OR code-splitting
- technique of downloading only what you need
- only load component once you need it
- depends heavily on the webpack configuration


hoc/asyncComponent.js
import React, { Component } from "react";

const asyncComponent = (importComponent) => {
    return class extends Component {
        state = {
            component: null
        }

        componentDidMount() {
            importComponent()
            .then(cmp => {
                this.setState({component: cmp.default});
            });
        }

        render () {
            const C = this.state.component;

            return C ? <C {...this.props} /> : null;
        }
    }
}

export default asyncComponent;

blog.js
import asyncComponent from '../../hoc/asyncComponent';

const AsyncNewPost = asyncComponent(() => {
    return import('./NewPost/NewPost');
});

<AsyncNewPost />

new lazy-loading

import { Suspense } from 'react';

const Post = React.lazy(() => import('./NewPost/NewPost'));

<Suspense fallback={<div>Loading...</div>}><NewPost /></Suspense>

----

routing & the server (deployment)

User -------> Server 			React App
		  (handles requests	  (knows the routes!)
			first!)
			(404 Error) ----> (always load index.html!)
		(example.com/my-app)  (Set base path!)


- configure the sever in a way that it always forwards request no matter if it understands them or not
- always load index.html even unknown request. this allows react to take over and parse the request against the routes it knows

<BrowserRouter basename="/my-app">

--------

Redux
- standalone third party library
- exists to make state management easier

What is State?
- is user authenticate?
- is a modal open? is a backdrop open?
- it's less about data, it's more about pure UI only state
- state influences what you see on screen

redux
- gives a certain flow of data, certain way of managing data so that we can nicely integrate with another package into the react app so that react does react to changes of data

	---------------> Reducers (receive action,update State)
	|					|
	|				 Updates
	|					v
  Action		   Central Store ------------Triggers-----
	^			  (stores entire                 		 |
Dispatches		  application state)             		 v
	|										(Automatic) Subscription
	|													 |
Component <---------Passes updated State as Props---------
(wants to
manipulate
state)




central store
- stores the entire application state
- kinda like a giant javascript object

Action
- pre-defined information package (possibly with payload)
- examples.. (addIngredient, removeIngredient)
- an information packaged we're sending to redux
- doesn't directly reach the store, doesn't hold any logic, doesn't know how to update the store (it's just a messenger)

Reducer
- Receive action and old State as input and then spits out updated State (pure, sync functions, no side-effects!)
- can combine multiple reducers
- checks to type of the action (ex. addIngredient) , define the code for that type of action in reducer
- has to execute synchronous code only (no async code, no side-effects, no HTTP requests)
- Updating has to be done in an immutable way (must always return a new State) which can be based on the old one but mut technically be a new javascript object
- Only thing that updates the state

Subscription
- takes an argument, a function that will be executed whenever the state is updated, so whenever an action reaches the reducer
- The store triggers all subscriptions whenever the state changes, whenever the state is updated in the store
- component can subscribe to store updates, it then receives that update automatically
- subscriptons make sure you don't have to manually call getState if you want to get the current state, inform you went you want to get a new state because something changed

--------

npm i @reduxjs/toolkit react-redux
OLD npm i redux react-redux

----

node.js import
const redux = require('redux');

----

es6 default value in function
const initialState = 1
const rootReducer = (state = initialState, action) => {};

----

if your container only needs to dispatch actions but doesnt need a slice of the State just pass null
export default connect(null, mapDispatchToProps)(Counter);

----

immutable way of changing arrays

const initialState = {
    counter: 0,
    results: [],
}

return {
	...state,
	results: state.results.concat({value: state.counter})
}

----

					  	Types of State
		Type				Example						 Use Redux?
 Local UI State 	 	Show/Hide Backdrop    		Mostly handled within
 													components

 Persistent State 		All Users, all Posts, ...   Stored on Server, relevant
 													slice managed by Redux

Client State 			Is Authenticated? Filters	Managed via Redux
						set by User, ...

----

es6 dynamically override a property in a given javascript object

return {
	...state,
	ingredients: {
		...state.ingredients,
		[action.ingredientName]: state.ingredients[action.ingredientName] + 1
	}
}

--------

Advanced Redux

Middleware
- basically functions (code in general) you hook into a process which then gets executed as part of that process without stopping it
- can do something with an action before it reaches the reducer (can be as simply logging something) (code we want to run between the action and reducer)
- becomes important when you want to execute asynchronous code


	--Middleware---> Reducers (receive action,update State)
	|					|
	|				 Updates
	|					v
  Action		   Central Store ------------Triggers-----
	^			  (stores entire                 		 |
Dispatches		  application state)             		 v
	|										(Automatic) Subscription
	|													 |
Component <---------Passes updated State as Props---------
(wants to
manipulate
state)


simple logger middleware

import { configureStore } from '@reduxjs/toolkit';

const logger = store => {
    return next => {
        return action => {
            console.log('[Middleware] Dispatching', action);
            const result = next(action);
            console.log('[Middleware] next state', store.getState());
            return result;
        }
    }
}

const store = configureStore({
    reducer: rootReducer, 
    middleware: [logger]
});

Another way is to add to default middleware
const store = configureStore({
  reducer: rootReducer,
  middleware: (getDefaultMiddleware) => getDefaultMiddleware().concat(logger),
});

----

Redux devtool

NEW WAY
- just install extension

----

Action creators
- just a function that returns an action or which creates an action

----

Redux-funk library
- adds a middleware to app that allows action creators to not return the action itself but return a function that will dispatch an action
- this allows for asynchronous code

if using Redux Toolkit thunk is included by default

const store = configureStore({
    reducer: rootReducer,
    middleware: (getDefaultMiddleware) => getDefaultMiddleware().concat(logger),
});

if using basic Redux store
npm i redux-thunk

- only synchronous actions may edit the store

----

mass export from one index file

index.js
export {
    add,
    subtract,
    increment,
    decrement
} from './counter';

export {
    store_result,
    delete_result
} from './result';

----

Where to put Logic?

		Action Creators							Reducer
	  Can run Async code 				  Pure, Sync code only!

	  Shouldn't prepare the State 		Core Redux Concept Reducer
	  Update too much					update the state

- there can be reasons for putting the logic in either but you can justifiably put the logic in the reducer and not much logic into the action creator
- just be consistent about it
- you could also do data FORMAT changes in the action creators

----

Advanced reducers

utility.js
export const updateObject = (oldObject, updatedValues) => {
    return {
        ...oldObject,
        ...updatedValues
    }
};

case actionTypes.ADD: return updateObject(state, {counter: state.counter + action.payload.val})

--------

Authentication

- single page and multi-page application authentication are handled differently
- multi-page authentication is handled by having a session on the server and returning different pages after checking the validity of the user or the authentication status on the server
- using react you can check the authentication status of the user on the server but on on every request

(SPA = Single Page Application)

How Authenticattion Works

(request to
protected
resource)
	--------->Server (Stateless, RESTful API)
	|		  ^   | 
	|  (Auth) |   |(S̶e̶s̶s̶i̶o̶n̶)
	|   	  |   |
 (Token)   	  |	  |(Token)
	|   	  |   |     \
	|   	  |   |      \ Store
	|		  |   v       \
	----------S P A------localStorage

Token
- javascript object (encoded as JSON)
- stored in localStorage (allows the user to fetch the token even if the user leaves and revisits the page)
- pass the token along with request to protected resources
- Only the tokens sent by the server are accepted on the server
- you can't create a token on the client and send to the server

----

how to create token on server?

----

localStorage
- browser API

----

Security

localStorage can be accessed with cross-site scripting attacks and cross-site scripting are prevented by React, you can't output insecure code by default

Be careful and protect the Refresh token if it is to be used in app

route protection on the frontend with guards is important

the server should not return any data for unauthenticated users (this how you protect your data)
the frontend is only about providing a user experience and to prevent to user from accidentally visiting a page they shouldn't be able to

people can always look into your javascript code if they really want to but it's always good it make it a bit harder

--------

Testing

writing automated tests

	 Build App
		|
		|
		v
  Test manually in
	 Browser
	 	|
		|
		v
  Automatic Tests
		|
		|
		|
		v
 Ship app to Server

Unit tests
- tests that test a tiny fraction of app (tests a unit of app)
- if we change anything in our app and that breaks our app or breaks a component then the unit test will fail and we'll get a error (we won't have to manually test in the browser)
- very important in big applications
- instead of adding at the end of the build workflow you could do tes driven development (this puts the tests first, write tests before you write any application code)

why testing?
														First Draft		New Feature
Component should output "Hello"								PASS 			PASS

Component should always render component "PersonData"		PASS 			PASS

Component should always receive a "persons" prop 			PASS 			FAIL

Component should always render the "NewPerson" component 	PASS 			FAIL
when a "editable" (true) prop is received

----

testing tools

Test Runner 			Executes Tests and provides 			Jest
						Validation Library

Testing Utitilites 		"Simulates" the React App (mounts 		React Test Utils
						components, allows you to dig into 		Enzyme (DOESNT WORK WITH REACT 18)
						the DOM)

npm install --save-dev jest
npm install --save-dev react-test-renderer
npm install --save-dev @testing-library/react

----

What to Test

Don't test the library!
- React, axios, redux

Don't test too complex connections!

Do test isolated units!

Do test your conditional outputs!

----

mock
- replace
- good for working with async

--------

Deployment

Check(& Adject) Basepath				<BrowserRouter basename="/my-app">

Build & Optimize Project				npm run build in create-react-app project

Server must ALWAYS serve				To ensure that Routing works correctly
index.html (also for 404 cases)

Upload Build Artifacts to (static) 		In /build folder when using create-react-app
Server

--------

Roundup

static website
- a static website is a page that only uses html, javascript and css
- instead of using react router you usea a folder structure where each folder has an index.html file and the according assets belonging to the file in it
- Gatsby offers the capability to build a regular react app and spits out a static website based off the react app you build

react native
- react but for mobile apps, native iOS or Android apps
- you write javascript code and then react native compiles that to iOS and Android

Material-UI and React-Boostrap
- component library
- give you pre-build and pre-styled components

Preact
- lightweight alternative to React

--------

Animations

animations
- guide user attention, show the user what changed, make it nicer to the eye, very important concept

----

react transition group
- allows you to smoothly animate elements when are they are added and removed from the DOM

react motion
- alternative to react transition group
- uses real world physics to determine animations

react move
- another alternative
- a little more complicated

react router transition
- ANOTHER alternative
- Route transitions

--------

React Hooks

    Functional <------------Functiona with Hooks----------> Class-based
  Props in, JSX out  		Functional components		Uses props and state

  Great for presentation 	Hooks replace class-only	Business log goes in here
  							functionalities
  Focused on one/few 									Orachestrates components
  purposes 													
  																	^
  																	|
  															Lifecycle hooks
  															can be hard to use


what are React Hooks?
- javascript functions which can only be used from inside
Funcional Components or other Hooks

- Named useXYZ()

- Idea is to expose certain				Hooks are highly re-usable
	(possibly stateful)					and independent for each
functionalities to functional 					component
		components

- Hooks allow you to add state to functional components and to
share (possibly stateful) logic across components

- have nothing to do with Lifecycle Methods("Lifecycle Hooks")

- introduced with React 16.8

- Allow you to use functional 			Hooks for managing state,
	components only 					side effects (eg. Http
										requests) & more

- Build custom hooks to share stateful or stateless logic across
multiple components

----

react memo reminder
- only rerenders the component when the props it depends on change
and not always when the parent component changes

----

useState
- different from a class-based state where the state had to always be an object, when using useState() the state can be any value
- is detached from the component so the state survives rerender of the component

array destructuring
- allews you to pull elements out of an array and store them in separate variables

const [enteredTitle, setEnteredTitle] = useState('');
const [enteredAmount, setenteredAmount] = useState('');

<input type="text" id="title" value={enteredTitle}
onChange={event => setEnteredTitle(event.target.value)}

																-----------------
					 (calls)						 creates 	v				|
Functional Component -------> useState(initialState) -------> State---------|	|
MyComp = props => ...				|							|			|	|
		^							v							|			|	|
		|					Array with exactly two		Managed by React 	|	|
		--------------------	elements			   (behind the scenes)	|	|
									|										|	|
							----------------- 								|	|
							v 				v 								|	|
						 State 			  State 							|	|
						pointer 		  update --------------------------------
							|			 function 							|
							|												|
							-------------------------------------------------


----

useEffect()
- used to manage side-effects (side-effect means there is some logic that runs that effects your app, anything that you cannot manage with normal render flow (like a http request))
- by default useEffect gets executed right after AND for every render cycle

useEffect(function to render after every render cycle, an array with the dependencies of your function)

- second argument, only when the dependencies changes will the function re-run

useing useEffect() with [] as a second argument will act like ComponentDidMount. It runs ONLY ONCE (after the first render)

useEffect(() => {}, []);

- should configure the array (second arg) in an honest way, really specify your dependencies, if you have a dependency

useEffect(() => {
	console.log("RENDERING INGREDIENTS", userIngredients);
}, [userIngredients]);

In JS functions are objects and behave like any other value

object destructoring
const {onLoadingIngredients} = props;

cleanup
- will run for the previous effect before the new effect is applied

useEffect(() => {
	const timer = setTimeout(() => {
    }, 500);

	return () => {
      clearTimeout(timer);
    };
}, []);

if your have [] as dependences (ie the effect only runs once), the cleanup function runs when the component gets unmounted.

----

useCallback()
- caches a function so it survives rerun or cycles
- makes it so the function it wraps is not re-created on re-render

const filteredIngredientsHandler = useCallback(filteredIngredients => {
    setUserIngredients(filteredIngredients);
  }, []);

----

useRef
- allows you to create a reference

const inputRef = useRef();

<input
ref={inputRef}
type="text"
value={enteredFilter}
onChange={event => setEnteredFilter(event.target.value)}/>

----

setState & State Update Batching

setNewSet(oldState + 1) 	vs 		setNewSet(prevState => prevState +1)
				 React batches state updates!
				  			|
				  			v
				 All state updates from one
				and the same synchonous event
				handler are batched together!

				 After setNewState(), you can't
				immediatley use the new state when
				 NOT using the function form!

----

useReducer()
- reducers are functions that take some input and return some output
- useReducer() uses that and gives a clear defined way of finding state changes in sate updates and it will manage the state for you
- useReducer() has no connection to the REdux library
- React will re-render the component whenever your reducer returns the new state
- useful when you have more complex state, state that relies on the old state, or if multiple state values work together

const ingredientReducer = (currentIngredients, action) => {
  switch (action.type) {
    case 'SET_INGREDIENT':
      return action.ingredients;
    case 'ADD_INGREDIENT':
      return [...currentIngredients, action.ingredient];
    case 'DELETE_INGREDIENT':
      return currentIngredients.filter(ing => ing.id !== action.id);
    default:
      throw new Error('Should not get to default case in ingredientReducer!');
  }
}

// Inside component function
const [userIngredients, dispatch] = useReducer(ingredientReducer, []);

----

useContext()
- helps handle cases where you need certain data in multiple components and you dont want to pass that state across multiple layers

import React, {useState} from 'react';

export const AuthContext = React.createContext({
    iSAuth: false,
    login: () => {}
});

src/context/auth-context.js
const AuthContextProvider = props => {
    const [isAuthenticated, setIsAuthenticated] = useState(false);

    const loginHandler = () => {
        setIsAuthenticated(true);
    }
    return (
        <AuthContext.Provider
        value={{login: loginHandler, isAuth: isAuthenticated}}>
            {props.children}
        </AuthContext.Provider>
    );
}

export default AuthContextProvider;

index.js
root.render(
    <AuthContextProvider>
        <App />
    </AuthContextProvider>
);

app.js
import { AuthContext } from './context/auth-context';

const App = props => {
  const authContext = useContext(AuthContext)

  let content = <Auth />;
  if (authContext.isAuth) {
    content = <Ingredients />;
  }
  return content;
};

----

useMemo()
- hook where you can save a value so the value isn't re-created, another way of memorizing a component
- if you're storing components you typically want to use react memo instead of useMemo BUT with useMemo you store any data which you don't want to re-create on every re-render cycle (an operation that calculates a more complex value, a longer calculation, use useMemo)
- first argument, a function that react will execute for and should return the value that you want to memorize
- second argument, a list of dependencies (this tells react when it should re-run this function to create a new object that it should memorize)
-shouldn't wrap every component with react memo or useMemo b/c react always needs to check whether props changed and if it's a super small component re-rendering it might be faster then do that check

const ingredientList = useMemo(() => {
    return <IngredientList ingredients={userIngredients} onRemoveItem={removeIngredientHandler} />
  }, [userIngredients, removeIngredientHandler]);

----

custom hooks
- any component that uses your own hook as if you had the code written in the component directly, so not like one function shared by multiple components, no, each functional component gets its own SNAPSHOT of this hook
- a way to share logic and not data
- the hook will be called wherever the component that is using it gets re-executed

--------

Redux Saga
- alternative to Redux
- different approach of working with async code

npm i redux-saga

----

Sagas
- kind of functions which run up certain actions and handle all your side-effects logic (ex. accessing local storage, reaching out to a server, changing the route or executing a timer)


function* logout(action) {
    yield localStorage.removeItem('token');
    yield action.localStorage.removeItem('expirationDate');
    yield action.localStorage.removeItem('userId');
    yield put({
        type: actionTypes.AUTH_LOGOUT,
    });
}

* turns this function into a generator
- functions which can be executed incrementally
- you can pause during function execution to wait for async code to finish

yield
- means this step will be executed and it will wait for it to finish

----

call
- good for testing because you can easily mock call

import {call} from 'redux-saga/effects';

yield call([localStorage,  'removeItem'], "token");

----

all
- easier way to pass all the actions you want to yield
- can be used for (example two axios requests and you want to run them simulataneously you can use all)
- good option if you want to run multiple generators or multiple tasks simulataneously
export function* watchAuth() {
    yield all([
        takeEvery(actionTypes.AUTH_CHECK_TIMEOUT, checkAuthTimeoutSaga),
        takeEvery(actionTypes.AUTH_INITIATE_LOGOUT, logoutSaga),
        takeEvery(actionTypes.AUTH_USER, authUserSaga),
        takeEvery(actionTypes.AUTH_CHECK_STATE, authCheckStateSaga)
    ]);
}

----

takeLatest
- will automatically cancel any ongoing executions and always only execute the latest one

export function* watchOrder() {
    yield takeLatest(actionTypes.PURCHASE_BURGER, purchaseBurgerSaga);
    yield takeEvery(actionTypes.FETCH_ORDERS, fetchOrdersSaga);
}

--------

Nextjs
- minimalistic framework for server-rendered React apps
- forces a specific folder structure (manages a lot for you)
- gives you server side rendering out of the box
- makes the creation of React app more convenient (especially the server side rendering part)

server side rendering
- when a user enters a URL leading to your React app or one your pages it will pre-render that page on the server so that the server returns that pre-rendered html code
- server side rendering apps are very helpful if you have an app that is highly dependent on being found in search engines

			How Server Side Rendering Works (SSR)
						
						Server<---Fetch & Render React App--->React App code
						^	|
        First Page Load |	| Return rendered First Page
						|	| + React App Bundle
						|	v
					Client (Browser)-----
							^			|
							------------- Re-render on Client (Single-Page App)
																	(SPA)

npm run dev

----

changing routes with nextjs

import Link from "next/link";
import Router from "next/router";

<p>Go to <Link href="/auth">Auth</Link></p>

imperatively (with code)
<button onClick={() => Router.push('/auth')}></button>

----

styling

<style jsx>{`
    div {
        border: 1px solid #eee;
        box-shadow: 0 2px 3px #ccc;
        text-align: center;
    }
`}</style>

----

error handling

_error.js

import React from "react";
import Link from "next/link";

const errorPage = () => {
    return (
        <div>
            <h1>Oh no!, something went wrong.</h1>
            <p>Try <Link href="/auth">going home</Link>.</p>
        </div>
    );
};

export default errorPage;

----

components and lifecycle hooks

getInitialProps
- executed on the server first. Will only be executed on if you navigate there within the app. (if you navigate by typing the URL and hitting enter or refresh it navigated on the SERVER)
- it executed either on the server or the client. This gives you the ability to initialize your app before it loads
- on the server by using getInitialProps you could fetch data from database and then pre-populate the props with props of your choice


static async getInitialProps(context) {
    console.log(context);
    return{ appName: 'Super App'};
}

OR 

static getInitialProps(context) {
    console.log(context);
    const promise = new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve({ appName: 'Super App'});
        }, 1000);
    });
    // promise.then();
    return promise;
}

<h1>The Main Page of {this.props.appName}</h1>

getInitialProps in functional components

authIndexPage.getInitialProps = (context) => {
    const promise = new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve({appName: 'Super App (Auth)'});
        }, 1000);
    });
    // promise.then();
    return promise;
};

<h1>The Auth Index Page of {props.appName}</h1>

----

npm run build

To deploy you need a host which is able to run nodeJS because nextjs uses nodejs and only works on nodejs

ship your entire project there then
run npm start

--------

Webpack
- not just a bundler (concatonate files)
- also optimizes your files and you can hook in various plug-ins (loaders) to transform your files (ex transpile next generation javascript to current generation javascript)
- at its core the idea is to have js files, css files, jpg files and bundle them together (by analyzing connections between the files like imports and bundles everything together)

						   How it works

  Multiple Entry Points --->  entry
	are Possible		   (e.g. app.js)
								|
  File-type dependent ---->  Loaders
  transformation   (e.g. babel-loader, css-loader)
								|
     Global ------------->   Plugins
  transformation          (e.g. uglify)
								|
								v
  Correctly ordered, ------>  ouput
  concatenated output  (e.g. dist/bundle.js)

----

basic workflow requirements
- compile next-gen javascript features
- handle JSX
- css autoprefixing
- support image imports
- optimize code

----

.gitignore

npm init

npm i --save-dev webpack webpack-dev-server

src folder

index.html

assets folder

components folder

container folder

index.js

index.css

app.js

....

----

core libraries

npm i react react-dom react-router-dom

----

to use webpack

npm i --save-dev webpack-cli

npm i --save-dev @babel/core @babel/preset-env @babel/preset-react @babel/preset-stage-2 babel-loader @babel/plugin-proposal-class-properties


npm i --save-dev style-loader css-loader
npm i --save-dev postcss-loader
npm i --save autoprefixer

package.json
"browserslist": "> 1%, last 2 versions"

npm i --save-dev url-loader

webpack.config.js
const path = require('path');
const autoprefixer = require('autoprefixer');
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
    mode: 'development',
    entry: './src/index.js',
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'bundle.js',
        publicPath: ''
    },
    devtool: 'eval-cheap-module-source-map',
    module: {
        rules: [
            {
                test: /\.js$/,
                loader: 'babel-loader',
                exclude: /node_modules/
            },
            {
                test: /\.css$/,
                exclude: /node_modules/,
                use: [
                    {loader: 'style-loader'},
                    {loader: 'css-loader', options: {
                        importLoaders: 1,
                        modules: {
                            localIdentName: '[name]__[local]__[hash:base64:5]'
                        }
                        }
                    },
                    {loader: 'postcss-loader', options: {
                        postcssOptions: {
                            ident: 'postcss',
                            plugins: [
                                "autoprefixer"
                            ]
                        }
                    }}
                ]
            },
            {test: /\.(png|jpe?g|gif)$/,
            use: [
                {
                    loader: 'url-loader',
                    options: {
                        limit: 8000,
                        name: 'images/[name].[ext]'
                    }
                }
            ]
            }
        ]
    },
    plugins: [
        new HtmlWebpackPlugin({
            template: __dirname + '/src/index.html',
            filename: 'index.html',
            inject: 'body'
        })
    ]
};

npm i --save-dev html-webpack-plugin

npm i --save-dev file-loader

--------
EXTRA STUFF

{props.loading && <LoadingIndicator />}
this means the component will only render if the prop loading is true else null is shown (nothing) alternative to this
{props.loading ? <LoadingIndicator /> : null}

----

VS Code multi-line comment
Ctrl + / - will comment out all the lines with single line comments
Alt + Shift + A - will comment out all the lines with mult-line comments

----

Static property
- it can be accessed from outside without the need to instantiate an object based on this class first

Static methods
- static methods are often utility functions, such as functions to create or clone objects, whereas static properties are useful for caches, fixed-configuration, or any other data you don't need to be replicated across instances.

class Car {
	constructor(name) {
		this.name = name;
	}
	static hello() {
		return "Hello!!";
	}
}

let myCar = new Car("Ford");

// You can call 'hello()' on the Car Class:
document.getElementById("demo").innerHTML = Car.hello();

// But NOT on a Car Object:
// document.getElementById("demo").innerHTML = myCar.hello();
// this will raise an error. 
----
class Car {
  constructor(name) {
    this.name = name;
  }
  static hello(x) {
    return "Hello " + x.name;
  }
}
let myCar = new Car("Ford");
document.getElementById("demo").innerHTML = Car.hello(myCar); 

----