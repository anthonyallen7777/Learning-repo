javascript refresher

--------
CLASSES:
- blueprints for objects
- can have properties and methods
- methods: functions attached to classes
- properties: variables attached to classes
- supports inheritance

class Person {
	name = 'Max' #Property
	call = () => {...} #Method
}

const myPerson = new Person()
myPerson.call()
console.log(myPerson.name)

class Person extends Master

----
class Human {
	gender = 'male';

	printGender = () => {
	console.log(this.gender);
	}
}
class Person extends Human {
	name = 'Max';
	gender = 'female';

	printMyName = () => {
	console.log(this.name);
	}
}

const person = new Person();
person.printMyName();
person.printGender();
----

PROPERTIES

ES6
constructor() {
	this.myProperty = 'value'
}

ES7
myProperty = 'value'

----

METHODS

ES6
myMethod() {...}

ES7
myMethod = () => {...}


--------
OPERATORS:
- ...
- Spread: used to split up array elements OR object properties
const newArray = [...oldArray, 1, 2]
const newObject = {...oldObject, newProp:5}

- Rest: used to merge a list of function arguments into an array
function sortArgs(...args) {
	return args.sort()
}

----

const numbers = [1,2,3];
const newNumbers = [...numbers, 4];

console.log(newNumbers);

const person = {
	name: 'Max'
};

const newPersons = {
	...person,
	mood: 'happy'
}

console.log(newPerson);

const filter = (...args) => {
	return args.filter(el => el === 1);
}

console.log(filter(1, 2, 3));
--------
DESTRUCTURING
- Easily extract array elements or object properties and store them in variables
- Array Destructuring:
[a, b] = ['Hello', 'Max']
console.log(a) // Hello
console.log(b) // Max

- Object Destructuring:
{name} = {name:'Max', mood:'happy'}
console.log(name) // Max
console.log(mood) // undefined

----
const number = [1, 2, 3];
[num1, num2] = numbers;
console.log(num1, num2); // 1 2

[num1, , num3] = numbers;
console.log(num1, num3); // 1 3
--------
REFERENCE AND PRIMITIVE TYPES

Primitive types:
- numbers, strings, booleans
- they copy the values

const number = 1; //primitive type
const num2 = number; //copies the values

console.log(num2);

Reference types:
- objects, arrays
- whereas primitive types are stored in memory, reference types store a pointer to that place in memory

----
REFERENCE

const person = {
	name: 'Max'
}

const secondPerson = person;

person.name = 'Manu';

console.log(secondPerson);

----
REAL COPY

const person = {
	name: 'Max'
}

const secondPerson = {
	...person
};

person.name = 'Manu';

console.log(secondPerson);
--------
ARRAY FUNCTIONS

const numbers = [1, 2, 3];

const doubleNumArray = numbers.map((num) => {
	return num * 2;
});

console.log(numbers);
console.log(doubleNumArray);
--------


base syntax
--------

linting - tool reminds you if you are writing suboptimal code

npm or yarn - dependency management

bundler(ex: webpack) - write module code and split up over multiple files. This code gets bundled into only a couple of files when we ship it

babel + presets - compile code to run on as many browsers as possible

development server - webserver running on our machine to test code

register service worker: pre-cache script files

react component always has to render some html code to the dom

JSX:
- code used to write html but is not actual html
- etiquette says to nest everything in one root

In it's simplest form a Component is just a function that returns some JSX (some html)

PROPS
- props (properties) are the attributes you add onto your component
- they're set and passed from outside

when using class-based components, it's this.props

class PErson extends Component {
	render() {
	return <p>My name is {this.props}</p>;
	}
}

State:
- change your component at runtime
- state is managed from inside the component
- should be used with care (can make app unpredictable and hard to manage as it grows)
- updating state also updates props

Stateless Components (dumb components OR presentational components)
- have no internal state management
It is good practice to use stateless components as much as possible (makes app easier to maintain and manage)

Stateful Components (smart components OR container components)
- have internal state management
- only use state in a few select components

Method:
- a function of a class

Dont add function brackets to method in onclick b/c will immediately execute the function once react renders the component to the dom. Instead pass a Reference

Hook
- can manage state in functional components