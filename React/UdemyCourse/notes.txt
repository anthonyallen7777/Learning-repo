javascript refresher

--------
EXPORT & IMPORT

const person = {
	name: 'Jeff'
}

 export default person
----
export const clean = () => {...}

export const baseData = 10;
----
import person from './person.js'
import prs from './person.js'

import { baseData } from './utility.js'
import { clean } from: './utility.js'

Default export:
import person from './person.js'
import prs from './person.js'

Named export:
import { smth } from './utility.js'
import {smth as Smth} from './utility.js'
import * as bundled from './utility.js'

--------
CLASSES:
- blueprints for objects
- can have properties and methods
- methods: functions attached to classes
- properties: variables attached to classes
- supports inheritance

class Person {
	name = 'Max' #Property
	call = () => {...} #Method
}

const myPerson = new Person()
myPerson.call()
console.log(myPerson.name)

class Person extends Master

----
class Human {
	gender = 'male';

	printGender = () => {
	console.log(this.gender);
	}
}
class Person extends Human {
	name = 'Max';
	gender = 'female';

	printMyName = () => {
	console.log(this.name);
	}
}

const person = new Person();
person.printMyName();
person.printGender();
----

PROPERTIES

ES6
constructor() {
	this.myProperty = 'value'
}

ES7
myProperty = 'value'

----

METHODS

ES6
myMethod() {...}

ES7
myMethod = () => {...}


--------
OPERATORS:
- ...
- Spread: used to split up array elements OR object properties
const newArray = [...oldArray, 1, 2]
const newObject = {...oldObject, newProp:5}

- Rest: used to merge a list of function arguments into an array
function sortArgs(...args) {
	return args.sort()
}

----

const numbers = [1,2,3];
const newNumbers = [...numbers, 4];

console.log(newNumbers);

const person = {
	name: 'Max'
};

const newPersons = {
	...person,
	mood: 'happy'
}

console.log(newPerson);

const filter = (...args) => {
	return args.filter(el => el === 1);
}

console.log(filter(1, 2, 3));
--------
DESTRUCTURING
- Easily extract array elements or object properties and store them in variables
- Array Destructuring:
[a, b] = ['Hello', 'Max']
console.log(a) // Hello
console.log(b) // Max

- Object Destructuring:
{name} = {name:'Max', mood:'happy'}
console.log(name) // Max
console.log(mood) // undefined

----
const number = [1, 2, 3];
[num1, num2] = numbers;
console.log(num1, num2); // 1 2

[num1, , num3] = numbers;
console.log(num1, num3); // 1 3
--------
REFERENCE AND PRIMITIVE TYPES

Primitive types:
- numbers, strings, booleans
- they copy the values

const number = 1; //primitive type
const num2 = number; //copies the values

console.log(num2);

Reference types:
- objects, arrays
- whereas primitive types are stored in memory, reference types store a pointer to that place in memory

----
REFERENCE

const person = {
	name: 'Max'
}

const secondPerson = person;

person.name = 'Manu';

console.log(secondPerson);

----
REAL COPY

const person = {
	name: 'Max'
}

const secondPerson = {
	...person
};

person.name = 'Manu';

console.log(secondPerson);
--------
ARRAY FUNCTIONS

const numbers = [1, 2, 3];

const doubleNumArray = numbers.map((num) => {
	return num * 2;
});

console.log(numbers);
console.log(doubleNumArray);
--------


BASE SYNTAX
--------

linting - tool reminds you if you are writing suboptimal code

npm or yarn - dependency management

bundler(ex: webpack) - write module code and split up over multiple files. This code gets bundled into only a couple of files when we ship it
- helps import css into js files

babel + presets - compile code to run on as many browsers as possible

development server - webserver running on our machine to test code

register service worker: pre-cache script files

react component always has to render some html code to the dom

JSX:
- code used to write html but is not actual html
- etiquette says to nest everything in one root

In it's simplest form a Component is just a function that returns some JSX (some html)

PROPS
- props (properties) are the attributes you add onto your component
- they're set and passed from outside

when using class-based components, it's this.props

class PErson extends Component {
	render() {
	return <p>My name is {this.props}</p>;
	}
}

State:
- change your component at runtime
- state is managed from inside the component
- should be used with care (can make app unpredictable and hard to manage as it grows)
- updating state also updates props

Stateless Components (dumb components OR presentational components)
- have no internal state management
It is good practice to use stateless components as much as possible (makes app easier to maintain and manage)

Stateful Components (smart components OR container components)
- have internal state management
- only use state in a few select components

Method:
- a function of a class

Dont add function brackets to method in onclick b/c will immediately execute the function once react renders the component to the dom. Instead pass a Reference

// v THIS CAN BE INEFFICIENT WHEN SCALING PROJECT
onClick={() => this.switchNameHandler('Jeff!!')}

 MAY WANT TO USE v
 click={this.switchNameHandler.bind(this, "Jefferey!")}>

----
testMethod = () => {
	//using this type of method ensures that using 'this' always refers to the current class we're in

	this.setState({
	someState: 'some value'
	})    
}

Hook
- can manage state in functional components

--------
LISTS & CONDITIONALS

output content conditionally using javascript with ternary expression or better yet create variables

map operation - use on arrays to map objects or strings, etc into array of jsx elements and react will out these elements out and render to screen

add key to let react efficient update
--------
STYLING

Radium package
- lets us use inline styles with pseudo selectors and media queries
- wrap entire app in root component with StyleRoot so you can access radium functionality

export default Radium(App);
- this called a higher order component
- it's just a component wrapping another component adding extra functionality

Media queries can be used to check many things, such as:
- width and height of the viewport
- width and height of the device
- orientation (is the tablet/phone in landscape or portrait mode?)
- resolution

----

Styled components library
- making styled components very simple

backticks templates
- vanilla javascript feature
- used to define template literals
	- template literals are used to make strings easier
	- can interpolate any kind of expression in the template literal
	- can be multi-line

const Button = styled.button``
- function call that takes what text you pass it as styling for the button

----

npm run eject
- will eject from the under the hood configuration where you dont have access to the underlying web packed confile file, etc and gives you access

----
css modules feature

config/webpack.config.dev.js
config/webpack.config.prod.js

modules: true,
localIdentName: '[name]__[local]__[hash:base64:5]'

app.js

import classes from './App.css'

<div className={classes.App}>

^^^^^^
This css modules feature detects the import from the css file and understand not to just import the css as it is and instead look into the css and transforms every class name in a random unique class and returns a map mapped to the class names we choose
----
react-scripts 2 and higher you must vv

you can save the eject step and just

import classes from './Person.modules.css';
rename to Person.modules.css
--------
DEBUGGING
always check line number
use dev tool debugger
- source maps
- breakpoints and steps (in and outs)

use the React extension to get insight into app

----

StrictMode
- a tool for highlighting potential problems in an application
 - Strict mode checks are run in development mode only; they do not impact the production build

StrictMode currently helps with:
- Identifying components with unsafe lifecycles
- Warning about legacy string ref API usage
- Warning about deprecated findDOMNode usage
- Detecting unexpected side effects
- Detecting legacy context API
- Ensuring reusable state

----

ErrorBoundary component
- only use for cases that you know might fail and you know you can't control

componentDidCatch
- will be executed whenever a component we wrap with the ErrorBoundary throw an error
--------
COMPONENT DEEP DIVE

the render method should be lean and not contain too much jsx

containers
- manages the state
- manipulates the state

----
Stateful vs Stateless

stateless (dumb components)
- historically have always been functional components
- since React 16.8 functional components can manage state with useState hook

by splitting app into container components and dumb components you can keep your app manageable

----
(Use if you need to manage State or access to Lifecycle Hooks and don't want to use React Hooks)

Class-based
class XY extends Component
- access to state
- lifecycle hooks
access state and props via "this"
this.state.XY & this.props.XY
----
(Use in all other Cases)
Functional
const XY = prop => {...}
- access to state(useState())
X (NOT SUPPORTED YET) lifecycle hooks
props.XY
----
Component Lifecycle
- Only available in Class-based Components

constructor()
getDerivedStateFromProps()
getSnapshotBeforeUpdate()
componentDidCatch()
componentWillUnmount()
shouldComponentUpdate()
componentDidUpdate()
componentDidMount()
render()

(Lifecycle Hooks have nothing to do with React Hooks)

CREATION
Default ES6 class Feature - constructor(props)
 - Call super(props)
 - DO: Set up State
 - DONT: Cause side-effects
  - by side-effect it means sending http request, storing something in local browser storage, or sending analytics to google
  - this will impact performance and cause unnecessary re-renders

					|
					v

getDerivedStateFromProps(props,state)
- when ever your props change or class-based component you can sync your state to them
- DO: Sync state
- DONT: Cause side-effects

					|
					v

render()
- Prepare & Structure JSX code
- DO: Layout JSX and render html code
- DONT:
 - send http request or set any timeouts
 - nothing that will block the rendering process

					|
					v

Render Child Components

					|
					v

componentDidMount()
- DO: Cause side-effects
 - here you can make http requests
- DONT: Update State (triggers re-render)
 - dont update state here unless it's in a then block of a promise
 - dont call set state in here synchronously
 ----

 