React - client-side javascript library

why react?
- ui state becomes difficult to manage with vanilla js
- active community

--------

javascript refresher
VARIABLES

let -variable that is variable
const - something that is assigned once and never changed

----
EXPORT & IMPORT

const person = {
	name: 'Jeff'
}

 export default person
----
export const clean = () => {...}

export const baseData = 10;
----
import person from './person.js'
import prs from './person.js'

import { baseData } from './utility.js'
import { clean } from: './utility.js'

Default export:
import person from './person.js'
import prs from './person.js'

Named export:
import { smth } from './utility.js'
import {smth as Smth} from './utility.js'
import * as bundled from './utility.js'

--------
CLASSES:
- blueprints for objects
- can have properties and methods
- methods: functions attached to classes
- properties: variables attached to classes
- supports inheritance

class Person {
	name = 'Max' #Property
	call = () => {...} #Method
}

const myPerson = new Person()
myPerson.call()
console.log(myPerson.name)

class Person extends Master

----
class Human {
	gender = 'male';

	printGender = () => {
	console.log(this.gender);
	}
}
class Person extends Human {
	name = 'Max';
	gender = 'female';

	printMyName = () => {
	console.log(this.name);
	}
}

const person = new Person();
person.printMyName();
person.printGender();
----

PROPERTIES

ES6
constructor() {
	this.myProperty = 'value'
}

ES7
myProperty = 'value'

----

METHODS

ES6
myMethod() {...}

ES7
myMethod = () => {...}


--------
OPERATORS:
- ...
- Spread: used to split up array elements OR object properties
const newArray = [...oldArray, 1, 2]
const newObject = {...oldObject, newProp:5}

- Rest: used to merge a list of function arguments into an array
function sortArgs(...args) {
	return args.sort()
}

----

const numbers = [1,2,3];
const newNumbers = [...numbers, 4];

console.log(newNumbers);

const person = {
	name: 'Max'
};

const newPersons = {
	...person,
	mood: 'happy'
}

console.log(newPerson);

const filter = (...args) => {
	return args.filter(el => el === 1);
}

console.log(filter(1, 2, 3));
--------
DESTRUCTURING
- Easily extract array elements or object properties and store them in variables
- Array Destructuring:
[a, b] = ['Hello', 'Max']
console.log(a) // Hello
console.log(b) // Max

- Object Destructuring:
{name} = {name:'Max', mood:'happy'}
console.log(name) // Max
console.log(mood) // undefined

----
const number = [1, 2, 3];
[num1, num2] = numbers;
console.log(num1, num2); // 1 2

[num1, , num3] = numbers;
console.log(num1, num3); // 1 3
--------
REFERENCE AND PRIMITIVE TYPES

Primitive types:
- numbers, strings, booleans
- they copy the values

const number = 1; //primitive type
const num2 = number; //copies the values

console.log(num2);

Reference types:
- objects, arrays
- whereas primitive types are stored in memory, reference types store a pointer to that place in memory

----
REFERENCE

const person = {
	name: 'Max'
}

const secondPerson = person;

person.name = 'Manu';

console.log(secondPerson);

----
REAL COPY

const person = {
	name: 'Max'
}

const secondPerson = {
	...person
};

person.name = 'Manu';

console.log(secondPerson);
--------
ARRAY FUNCTIONS

const numbers = [1, 2, 3];

const doubleNumArray = numbers.map((num) => {
	return num * 2;
});

console.log(numbers);
console.log(doubleNumArray);
--------


BASE SYNTAX
--------

linting - tool reminds you if you are writing suboptimal code

npm or yarn - dependency management

bundler(ex: webpack) - write module code and split up over multiple files. This code gets bundled into only a couple of files when we ship it
- helps import css into js files

babel + presets - compile code to run on as many browsers as possible

development server - webserver running on our machine to test code

register service worker: pre-cache script files

react component always has to render some html code to the dom

JSX:
- code used to write html but is not actual html
- etiquette says to nest everything in one root

In it's simplest form a Component is just a function that returns some JSX (some html)

PROPS
- props (properties) are the attributes you add onto your component
- they're set and passed from outside

when using class-based components, it's this.props

class PErson extends Component {
	render() {
	return <p>My name is {this.props}</p>;
	}
}

State:
- change your component at runtime
- state is managed from inside the component
- should be used with care (can make app unpredictable and hard to manage as it grows)
- updating state also updates props

Stateless Components (dumb components OR presentational components)
- have no internal state management
It is good practice to use stateless components as much as possible (makes app easier to maintain and manage)

Stateful Components (smart components OR container components)
- have internal state management
- only use state in a few select components

Method:
- a function of a class

Dont add function brackets to method in onclick b/c will immediately execute the function once react renders the component to the dom. Instead pass a Reference

// v THIS CAN BE INEFFICIENT WHEN SCALING PROJECT
onClick={() => this.switchNameHandler('Jeff!!')}

 MAY WANT TO USE v
 click={this.switchNameHandler.bind(this, "Jefferey!")}>

----
testMethod = () => {
	//using this type of method ensures that using 'this' always refers to the current class we're in

	this.setState({
	someState: 'some value'
	})    
}

Hook
- can manage state in functional components

--------
LISTS & CONDITIONALS

output content conditionally using javascript with ternary expression or better yet create variables

map operation - use on arrays to map objects or strings, etc into array of jsx elements and react will out these elements out and render to screen

add key to let react efficient update
--------
STYLING

Radium package
- lets us use inline styles with pseudo selectors and media queries
- wrap entire app in root component with StyleRoot so you can access radium functionality

export default Radium(App);
- this called a higher order component
- it's just a component wrapping another component adding extra functionality

Media queries can be used to check many things, such as:
- width and height of the viewport
- width and height of the device
- orientation (is the tablet/phone in landscape or portrait mode?)
- resolution

----

Styled components library
- making styled components very simple

backticks templates
- vanilla javascript feature
- used to define template literals
	- template literals are used to make strings easier
	- can interpolate any kind of expression in the template literal
	- can be multi-line

const Button = styled.button``
- function call that takes what text you pass it as styling for the button

----

npm run eject
- will eject from the under the hood configuration where you dont have access to the underlying web packed confile file, etc and gives you access

----
css modules feature

config/webpack.config.dev.js
config/webpack.config.prod.js

modules: true,
localIdentName: '[name]__[local]__[hash:base64:5]'

app.js

import classes from './App.css'

<div className={classes.App}>

^^^^^^
This css modules feature detects the import from the css file and understand not to just import the css as it is and instead look into the css and transforms every class name in a random unique class and returns a map mapped to the class names we choose
----
react-scripts 2 and higher you must vv

you can save the eject step and just

import classes from './Person.module.css';
rename to Person.modules.css
--------
DEBUGGING
always check line number
use dev tool debugger
- source maps
- breakpoints and steps (in and outs)

use the React extension to get insight into app

----

StrictMode
- a tool for highlighting potential problems in an application
 - Strict mode checks are run in development mode only; they do not impact the production build

StrictMode currently helps with:
- Identifying components with unsafe lifecycles
- Warning about legacy string ref API usage
- Warning about deprecated findDOMNode usage
- Detecting unexpected side effects
- Detecting legacy context API
- Ensuring reusable state

----

ErrorBoundary component
- only use for cases that you know might fail and you know you can't control

componentDidCatch
- will be executed whenever a component we wrap with the ErrorBoundary throw an error
--------
COMPONENT DEEP DIVE

the render method should be lean and not contain too much jsx

containers
- manages the state
- manipulates the state

----
Stateful vs Stateless

stateless (dumb components)
- historically have always been functional components
- since React 16.8 functional components can manage state with useState hook

by splitting app into container components and dumb components you can keep your app manageable

----
(Use if you need to manage State or access to Lifecycle Hooks and don't want to use React Hooks)

Class-based
class XY extends Component
- access to state
- lifecycle hooks
access state and props via "this"
this.state.XY & this.props.XY
----
(Use in all other Cases)
Functional
const XY = prop => {...}
- access to state(useState())
X (NOT SUPPORTED YET) lifecycle hooks
props.XY
----

Component Lifecycle Methods or Component Lifecycle Hook
- Only available in Class-based Components

constructor()
getDerivedStateFromProps()
getSnapshotBeforeUpdate()
componentDidCatch()
componentWillUnmount()
shouldComponentUpdate()
componentDidUpdate()
componentDidMount()
render()

(Lifecycle Hooks have nothing to do with React Hooks)

Component Lifecycle - CREATION

constructor(props)
- Default ES6 class Feature
- Call super(props)
 - basically executes the contructor of the component you're extending (important so that everything get initialized correctly)
- DO: Set up State
- DONT: Cause Side-Effects
 - by side-effect it means sending http request, storing something in local browser storage, or sending analytics to google
 - this will impact performance and cause unnecessary re-renders

					|
					v
getDerivedStateFromProps(props,state)
- when ever your props change or class-based component you can sync your state to them
- DO: Sync state
- DONT: Cause Side-Effects

					|
					v
render()
- Prepare & Structure JSX code
- DO: Layout JSX and render html code
- DONT:
 - send http request or set any timeouts
 - nothing that will block the rendering process

					|
					v
Render Child Components

					|
					v
componentDidMount()
- DO: Cause Side-Effects
 - here you can make http requests
- DONT: Update State (triggers re-render)
 - dont update state here unless it's in a then block of a promise
 - dont call set state in here synchronously
----
Component Lifecycle - UPDATE

getDerivedStateFromProps(props,state)
- used to initialize the state of a component that updates based on props you're getting
- maybe some form control that gets external properties and want to interally handle user input
- DO: Sync State to Props
- DONT: Cause Side-Effects

					|
					v
shouldComponentUpdate(nextProps, nextState)
- May cancel updating process
- DO: Decide whether to Continue or Not
- DONT: Cause Side-Effects
- For performance optimization
- use carefully
- does a shallow comparison
 - as in for example arrays it compares the pointers not what the array is pointing to

					|
					v
render()
- Prepare & Structor JSX Code

					|
					v
Update Child Component Props

					|
					v
getSnapshotBeforeUpdate(prevProps, prevState)
 - use to save some data before the update and use it in the update
- DO: Last-minute DOM operations
 - like getting the current scrolling position of user
- DONT: Cause Side-Effects

					|
					v
componentDidUpdate()
- Most commonly used component
- DO: Cause Side-Effects
 - make http requests
- DONT: Update State (triggers re-render)
- don't update the state synchronously
- careful not to get caught in infinite loop here (ex when making http request and updating component)
----

Most important hooks
componentDidMount()
- typically fetching data from a server
componentDidUpdate()
- typically fetching data from a server
shouldComponentUpdate()
- for performance improvements

----

useEffect
- second most important next to useState
- basically combines the functionality or the use cases of all class-based lifecycle hook in one react hook
- not a lifecycle hook
- this is a React hook so you can add it into components
- can send http requests
- runs when component is created as well
takes a function that will run every render cycle


cleanup work
componentWillUnmount
- code run right before component is removed

useEffect cleanup
- can be ran when the component get destroyed (empty argument [] , or on every update (no argument), or pass an array that list all the data to watch and only when that data changes does it run the function useEffect then run the cleanup function

below we are cleaning up when the component is destroyed (an empyty array is passed)

useEffect(() => {
	console.log('[test.js useEffect');

	//this function is run before the main useEffect function runs but after the (first) render cycle
	return () => {
		console.log('[test.js] cleanup work in useEffect')
	}
}, []);

----

React.memo();

memoization
- technique where React will store a snapshot of this component and only if its input changes, it will re-render it and otherwise if its input do not change react will give back the stored component
- great way of getting optimization for functional components

----

PureComponent
- just a normal component that already implements shouldComponentUpdate with a complete props check that check for any changes for any prop in that component

----

How React Updates the (Real) DOM (the DOM in the browser)

render() is called
- render is like a suggestion of what the HTML should look like in the end, it can show what is already displayed
- this also applies to functional components and the JSX returned there, NOT just class-based components
- use shouldComponentUpdate() to prevent unnecessary render calls

Old Virtual DOM
<div>...<div>
- Faster than the "real" DOM
- it's simply a DOM representation in Javascript

Re-render Virtual DOM
<div>...<div>
- created when the render() method is called
- render() doesn't immediately update the "real" DOM!

It compares the old virtual DOM to the new one and checks if there are any differences
- if there are differences it reaches to the real DOM and updates it and only changes the places where difference were detected
- if no differences were found, then it doesn't touch the real DOM

accessing the DOM is really slow, it's something you want to do as little as possible

----

adjacent jsx elements

return [
	<p key='i1'>Hello</p>,
	<p key='i2'>I Am Adjacent</p>,
	<input key='i3' type="text"/>
];

Auxillary components
- used as a wrapper in cases where you want adjacentelements without extra DOM element being rendered
- HOC (higher order component)

aux.js
const aux = props => props.children;
export default aux;

props.children
- simply outputs whatever gets entered between the opening and closing tag this component

React.Fragment
- does the same thing as the Aux component

----

HOC
- Higher Order Component
- component that wraps other components that adds something to it (styling, additional HTML structure, or some logic)

----

passing unknown props

return props => (
    <div className={className}>
        <WrappedComponent {...props} />
    </div>
);
- the spread operator pull out all the properties that  are inside of this props object and distributes them as new key-value pairs on the wrapped component

----
SUPER IMPORTANT STUFF RIGHT HERE
setting state correctly

setState does not immediately trigger an update of the state of the component in a re-render cycle, instead it is scheduled by React and React will perform the state update and re-render when it has the resources

this.setState((prevState, props) => {
  return {
    persons: persons,
    changeCounter: prevState.changeCounter + 1
  };
});

----
propTypes

npm install --save prop-types

Person.propTypes = {
    click: PropTypes.func,
    name: PropTypes.string,
    age: PropTypes.number,
    changed: PropTypes.func
};
- special javascript property that can be added to any javascript component object that React will watch out for in dev mode and give a warning if you pass in incorrect props

this is especially helpful when you distribute components as a package to other devs or when working with a team
----
using refs in class-based components
(references)

ref
- just like key is a special property that is understood by React


1st approach
componentDidMount() {
    this.inputElement.focus();
}

<input
ref={(inputEl) => {this.inputElement = inputEl}}
/>
- this gives you a reference to the element you've placed it on

2nd approach (more modern approach)
constructor() {
	this.inputElementRef = React.createRef();
}

componentDidMount() {
    this.inputElementRef.current.focus();
}

<input
ref={(inputEl) => {this.inputElement = inputEl}}
/>
----
understand problems with prop chains

Context
- helps handle cases where you need certain data in multiple components and you dont want to pass that state across multiple layers
- object, array, string, or number that can be passed between React components without using props

contextType

auth-context.js
const authContext = React.createContext({
    authenticated: false,
    login: () => {}
});

app.js
<AuthContext.Provider value={{
	authenticated: this.state.authenticated,
	login: this.loginHandler
}}>

CONTEXTTYPE

import AuthContext from '../../../context/auth-context';

static contextType = AuthContext;

console.log(this.context.authenticated);

OR

USECONTEXT

import React, { useContext } from "react";

const authContext = useContext(AuthContext);

console.log(authContext.authenticated);
--------

LEARN PROJECT
----

Planning a React App
Component Tree/Component Structure

Application State(Data)

Components vs Containers

----

class componentName extends Component {
	
}

^^^^ we can still use this as functional (dumb) component if we omit the state. It doesn't just become a stateful component just because we use class instead of a function form

inside a class you access props with this.props

font-size: 1.2rem; //scales the font-size based on the font-size the user selected

{salad: 1, bacon: 1, cheese: 2, meat: 2}
					|
					|
					v
	['salad', 'bacon', 'cheese', 'meat']
					|
					|
					v
[['salad', 1], ['bacon', 1], ['cheese', 2], ['meat', 2]]


reduce((arr, el) => {
	return arr.concat(el) // [] + [] = []
}, []);

transform an array into something else

----

// Must be in this format to reference this.setState({});

func = () => {
	this.setState({});
} 

----

z-index
- the higher the value the closer it is to the you
- the lower the value the further away it is from the you

----

Mobile first way
- base classes are for mobile devices then add media queries to make it look good on bigger devices

----

<Modal>
	<OrderSummary/>
</Modal>

- The wrapping element (Modal) controls the updating of the wrapped element (OrderSummary)

--------

HTTP

----

Ajax

react
- library for front-end
- the code running in the browser

http requests in React (typically)
- decoupling
- there is a strong differentiation between your frontend, react app, and you backend, server

S E R V E R 
|	^	|
X	| (JSON Data)
|	|	|
v	|	v
REACT  APP

Server is typically a RESTful API
- just exposing some API endpoints to which you can send requests to get or send data from your standalone react app

Two way to send Ajax request
- XML HTTP request (XMLHttpRequest)
 - you can use this to construct your own Ajax request and send them to a specific url and handle the response
- Axios
 - a third party javascript library
 - can be used in any javascript code

componentDidMount()
- this where we should fetch data (HTTP requests)
- but NOT for updating state (because it triggers a re-render)

.then();
- takes a function a input and the function is executed when the promise resolves (once the data from backend is here)


real app you could send some query parameter to backend to restrict the amount of data you want
 - pagination (basically)


() => this.postSelectedHandler(post.id)
- reason to use this to to be able to pass an argument to the function

componentDidUpdate()
- here we can also fetch data (http request)

GET
200 - Successful

POST
201 - Successful

DELETE
200 - Successful

----

Interceptors
- functions defined globally which will we executed every request leaving app and every response returning into app
- this useful for setting headers (authorization headers), or logging responses, or handling errors globally

index.js
axios.interceptors.request.use(request => {
  console.log(request);
  // Edit request config
  return request;
}, error => {
  console.log(error);
  return Promise.reject(error);
});

axios.interceptors.response.use(response => {
  console.log(response);
  return response;
}, error => {
  console.log(error);
  return Promise.reject(error);
})

----

setting a default global configuration for axios

axios.defaults.baseURL = 'https://jsonplaceholder.typicode.com';
axios.defaults.headers.common['Authorization'] = 'AUTH TOKEN';
axios.defaults.headers.post['Context-Type'] = 'application/json';

axios instances
- give you flexibility
- allows you to control in detail which part of your app you want to use which default settings
 
root axios.js
const instance = axios.create({
    baseURL: 'https://jsonplaceholder.typicode.com',
});

instance.defaults.headers.common['Authorization'] = 'AUTH TOKEN FROM INSTANCE';

blog.js
import axios from '../../axios';


http requests in Multi-page application in React
- a page submits a form
- that sends a request to the backend (with potentially new react code)
- you get back new html page with (potentially new react code)

--------

FIREBASE

----
database

using realtime database
- we wont connect directly to the database we just send http request and firebase does the mapping of the http endpoints to the database

ONLY IN THE DEV ENVIRONMENT SHOULD THE READ AND WRITE RULES BE SET TO TRUE


Firebase POST
- when posting each list item gets a unique ID assigned by firebase automatically

axios.post('/orders.json', order)
.then(res => {
    console.log(res);
})
.catch(err => {
    console.log(err);
});

----

pass props and error handling
const withErrorHandler = (WrappedComponent, axios) => {
    return (props) => {
        return (
        <Aux>
            <Modal show>
                Something didn't work!
            </Modal>
            <WrappedComponent {...props} />
        </Aux>
        );
    };
};

//prevent memory leaks by ejecting interceptors
//because this component will be run on multiple other components (it's a HOC component)
//we need to make sure it doesn't create lots of interceptors that sit around in memory
componentWillUnmount() {
    // console.log('Will Unmount', this.requestInterceptor, this.responseInterceptor);
    axios.interceptors.request.eject(this.requestInterceptor);
    axios.interceptors.response.eject(this.responseInterceptor);
}

--------

ROUTING
- Routing is about being able to show different pages to the user
- routing is about parsing paths, so the path after our domain and showing the appropriate JSX or component code
- load conditional JSX or component code for different paths
- use a router package so we dont have to determine which path the user is on on our own

					Single Page
					(HTML File)

/ 		/blog		/blog/post/1	/users	/account	orders
		(Not real Files but re-rendered Single Page!)

					Router Package
Parses URL /Path -> Read Config -> Render / Load appropriate JSX / Component

- we don't actually have different files but we just re-render part of the single page or the entire page depending on which path the user navigated to

npm i react-router react-router-dom
react-router
react-router-dom
- defacto standard packages for routing in React

As long as you're user is navigating around you rarely want to reload, you want to just re-render the page in the parts where it needs to be rendered so it looks a reload
- this is super IMPORTANT because not reloading when navigating routes makes it so our state is saved

absolute path
- an absolute path is always appended to your domain

relative path
- 


Passing parameters

<Link
to={'/' + post.id}
key={post.id}>
    <Post
    title={post.title}
    author={post.author}
    clicked={() => this.postSelectedHandler(post.id)} />
</Link> );

<Route path="/:id" exact element={<FullPost />} />


<Switch> is pretty much <Routes> in react-router-dom v6

----

Navigation guard
- typical used when you dont know if a user is authenticated or not and there are some routes in your app you only want to allow the user to visit if they are authenticated

----
404

<Route path="*" element={<h1>Not Found.</h1>} />
- always last

----

lazy-loading OR code-splitting
- technique of downloading only what you need
- only load component once you need it
- depends heavily on the webpack configuration


hoc/asyncComponent.js
import React, { Component } from "react";

const asyncComponent = (importComponent) => {
    return class extends Component {
        state = {
            component: null
        }

        componentDidMount() {
            importComponent()
            .then(cmp => {
                this.setState({component: cmp.default});
            });
        }

        render () {
            const C = this.state.component;

            return C ? <C {...this.props} /> : null;
        }
    }
}

export default asyncComponent;

blog.js
import asyncComponent from '../../hoc/asyncComponent';

const AsyncNewPost = asyncComponent(() => {
    return import('./NewPost/NewPost');
});

<AsyncNewPost />

new lazy-loading

import { Suspense } from 'react';

const Post = React.lazy(() => import('./NewPost/NewPost'));

<Suspense fallback={<div>Loading...</div>}><NewPost /></Suspense>

----

routing & the server (deployment)

User -------> Server 			React App
		  (handles requests	  (knows the routes!)
			first!)
			(404 Error) ----> (always load index.html!)
		(example.com/my-app)  (Set base path!)


- configure the sever in a way that it always forwards request no matter if it understands them or not
- always load index.html even unknown request. this allows react to take over and parse the request against the routes it knows

<BrowserRouter basename="/my-app">

--------

Redux
- standalone third party library
- exists to make state management easier

What is State?
- is user authenticate?
- is a modal open? is a backdrop open?
- it's less about data, it's more about pure UI only state
- state influences what you see on screen

redux
- gives a certain flow of data, certain way of managing data so that we can nicely integrate with another package into the react app so that react does react to changes of data

	---------------> Reducers (receive action,update State)
	|					|
	|				 Updates
	|					v
  Action		   Central Store ------------Triggers-----
	^			  (stores entire                 		 |
Dispatches		  application state)             		 v
	|										(Automatic) Subscription
	|													 |
Component <---------Passes updated State as Props---------
(wants to
manipulate
state)




central store
- stores the entire application state
- kinda like a giant javascript object

Action
- pre-defined information package (possibly with payload)
- examples.. (addIngredient, removeIngredient)
- an information packaged we're sending to redux
- doesn't directly reach the store, doesn't hold any logic, doesn't know how to update the store (it's just a messenger)

Reducer
- Receive action and old State as input and then spits out updated State (pure, sync functions, no side-effects!)
- can combine multiple reducers
- checks to type of the action (ex. addIngredient) , define the code for that type of action in reducer
- has to execute synchronous code only (no async code, no side-effects, no HTTP requests)
- Updating has to be done in an immutable way (must always return a new State) which can be based on the old one but mut technically be a new javascript object
- Only thing that updates the state

Subscription
- takes an argument, a function that will be executed whenever the state is updated, so whenever an action reaches the reducer
- The store triggers all subscriptions whenever the state changes, whenever the state is updated in the store
- component can subscribe to store updates, it then receives that update automatically
- subscriptons make sure you don't have to manually call getState if you want to get the current state, inform you went you want to get a new state because something changed

--------

npm i @reduxjs/toolkit react-redux
OLD npm i redux react-redux

----

node.js import
const redux = require('redux');

----

es6 default value in function
const initialState = 1
const rootReducer = (state = initialState, action) => {};

----

if your container only needs to dispatch actions but doesnt need a slice of the State just pass null
export default connect(null, mapDispatchToProps)(Counter);

----

immutable way of changing arrays

const initialState = {
    counter: 0,
    results: [],
}

return {
	...state,
	results: state.results.concat({value: state.counter})
}

----

					  	Types of State
		Type				Example						 Use Redux?
 Local UI State 	 	Show/Hide Backdrop    		Mostly handled within
 													components

 Persistent State 		All Users, all Posts, ...   Stored on Server, relevant
 													slice managed by Redux

Client State 			Is Authenticated? Filters	Managed via Redux
						set by User, ...

----

es6 dynamically override a property in a given javascript object

return {
	...state,
	ingredients: {
		...state.ingredients,
		[action.ingredientName]: state.ingredients[action.ingredientName] + 1
	}
}

--------

Advanced Redux

Middleware
- basically functions (code in general) you hook into a process which then gets executed as part of that process without stopping it
- can do something with an action before it reaches the reducer (can be as simply logging something) (code we want to run between the action and reducer)
- becomes important when you want to execute asynchronous code


	--Middleware---> Reducers (receive action,update State)
	|					|
	|				 Updates
	|					v
  Action		   Central Store ------------Triggers-----
	^			  (stores entire                 		 |
Dispatches		  application state)             		 v
	|										(Automatic) Subscription
	|													 |
Component <---------Passes updated State as Props---------
(wants to
manipulate
state)


simple logger middleware

import { configureStore } from '@reduxjs/toolkit';

const logger = store => {
    return next => {
        return action => {
            console.log('[Middleware] Dispatching', action);
            const result = next(action);
            console.log('[Middleware] next state', store.getState());
            return result;
        }
    }
}

const store = configureStore({
    reducer: rootReducer, 
    middleware: [logger]
});

Another way is to add to default middleware
const store = configureStore({
  reducer: rootReducer,
  middleware: (getDefaultMiddleware) => getDefaultMiddleware().concat(logger),
});

----

Redux devtool

NEW WAY
- just install extension

----

Action creators
- just a function that returns an action or which creates an action

----

Redux-funk library
- adds a middleware to app that allows action creators to not return the action itself but return a function that will dispatch an action
- this allows for asynchronous code

if using Redux Toolkit thunk is included by default

const store = configureStore({
    reducer: rootReducer,
    middleware: (getDefaultMiddleware) => getDefaultMiddleware().concat(logger),
});

if using basic Redux store
npm i redux-thunk

- only synchronous actions may edit the store

----

mass export from one index file

index.js
export {
    add,
    subtract,
    increment,
    decrement
} from './counter';

export {
    store_result,
    delete_result
} from './result';

----

Where to put Logic?

		Action Creators							Reducer
	  Can run Async code 				  Pure, Sync code only!

	  Shouldn't prepare the State 		Core Redux Concept Reducer
	  Update too much					update the state

- there can be reasons for putting the logic in either but you can justifiably put the logic in the reducer and not much logic into the action creator
- just be consistent about it
- you could also do data FORMAT changes in the action creators

----

Advanced reducers

utility.js
export const updateObject = (oldObject, updatedValues) => {
    return {
        ...oldObject,
        ...updatedValues
    }
};

case actionTypes.ADD: return updateObject(state, {counter: state.counter + action.payload.val})

--------

Authentication

- single page and multi-page application authentication are handled differently
- multi-page authentication is handled by having a session on the server and returning different pages after checking the validity of the user or the authentication status on the server
- using react you can check the authentication status of the user on the server but on on every request

(SPA = Single Page Application)

How Authenticattion Works

(request to
protected
resource)
	--------->Server (Stateless, RESTful API)
	|		  ^   | 
	|  (Auth) |   |(S̶e̶s̶s̶i̶o̶n̶)
	|   	  |   |
 (Token)   	  |	  |(Token)
	|   	  |   |     \
	|   	  |   |      \ Store
	|		  |   v       \
	----------S P A------localStorage

Token
- javascript object (encoded as JSON)
- stored in localStorage (allows the user to fetch the token even if the user leaves and revisits the page)
- pass the token along with request to protected resources
- Only the tokens sent by the server are accepted on the server
- you can't create a token on the client and send to the server

----

how to create token on server?

----

localStorage
- browser API

----

Security

localStorage can be accessed with cross-site scripting attacks and cross-site scripting are prevented by React, you can't output insecure code by default

Be careful and protect the Refresh token if it is to be used in app

route protection on the frontend with guards is important

the server should not return any data for unauthenticated users (this how you protect your data)
the frontend is only about providing a user experience and to prevent to user from accidentally visiting a page they shouldn't be able to

people can always look into your javascript code if they really want to but it's always good it make it a bit harder

--------

Testing

writing automated tests

	 Build App
		|
		|
		v
  Test manually in
	 Browser
	 	|
		|
		v
  Automatic Tests
		|
		|
		|
		v
 Ship app to Server

Unit tests
- tests that test a tiny fraction of app (tests a unit of app)
- if we change anything in our app and that breaks our app or breaks a component then the unit test will fail and we'll get a error (we won't have to manually test in the browser)
- very important in big applications
- instead of adding at the end of the build workflow you could do tes driven development (this puts the tests first, write tests before you write any application code)

why testing?
														First Draft		New Feature
Component should output "Hello"								PASS 			PASS

Component should always render component "PersonData"		PASS 			PASS

Component should always receive a "persons" prop 			PASS 			FAIL

Component should always render the "NewPerson" component 	PASS 			FAIL
when a "editable" (true) prop is received

----

testing tools

Test Runner 			Executes Tests and provides 			Jest
						Validation Library

Testing Utitilites 		"Simulates" the React App (mounts 		React Test Utils
						components, allows you to dig into 		Enzyme (DOESNT WORK WITH REACT 18)
						the DOM)

npm install --save-dev jest
npm install --save-dev react-test-renderer
npm install --save-dev @testing-library/react

----

What to Test

Don't test the library!
- React, axios, redux

Don't test too complex connections!

Do test isolated units!

Do test your conditional outputs!

----

mock
- replace
- good for working with async

--------

Deployment

Check(& Adject) Basepath				<BrowserRouter basename="/my-app">

Build & Optimize Project				npm run build in create-react-app project

Server must ALWAYS serve				To ensure that Routing works correctly
index.html (also for 404 cases)

Upload Build Artifacts to (static) 		In /build folder when using create-react-app
Server

--------

Roundup

static website
- a static website is a page that only uses html, javascript and css
- instead of using react router you usea a folder structure where each folder has an index.html file and the according assets belonging to the file in it
- Gatsby offers the capability to build a regular react app and spits out a static website based off the react app you build

react native
- react but for mobile apps, native iOS or Android apps
- you write javascript code and then react native compiles that to iOS and Android

Material-UI and React-Boostrap
- component library
- give you pre-build and pre-styled components

Preact
- lightweight alternative to React

--------

Bonus






























































































































































































































































--------
EXTRA STUFF

VS Code multi-line comment
Ctrl + / - will comment out all the lines with single line comments
Alt + Shift + A - will comment out all the lines with mult-line comments

Static property
- it can be accessed from outside without the need to instantiate an object based on this class first

Static methods
- static methods are often utility functions, such as functions to create or clone objects, whereas static properties are useful for caches, fixed-configuration, or any other data you don't need to be replicated across instances.

class Car {
	constructor(name) {
		this.name = name;
	}
	static hello() {
		return "Hello!!";
	}
}

let myCar = new Car("Ford");

// You can call 'hello()' on the Car Class:
document.getElementById("demo").innerHTML = Car.hello();

// But NOT on a Car Object:
// document.getElementById("demo").innerHTML = myCar.hello();
// this will raise an error. 
----
class Car {
  constructor(name) {
    this.name = name;
  }
  static hello(x) {
    return "Hello " + x.name;
  }
}
let myCar = new Car("Ford");
document.getElementById("demo").innerHTML = Car.hello(myCar); 

----

