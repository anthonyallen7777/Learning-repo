javascript refresher

--------
EXPORT & IMPORT

const person = {
	name: 'Jeff'
}

 export default person
----
export const clean = () => {...}

export const baseData = 10;
----
import person from './person.js'
import prs from './person.js'

import { baseData } from './utility.js'
import { clean } from: './utility.js'

Default export:
import person from './person.js'
import prs from './person.js'

Named export:
import { smth } from './utility.js'
import {smth as Smth} from './utility.js'
import * as bundled from './utility.js'

--------
CLASSES:
- blueprints for objects
- can have properties and methods
- methods: functions attached to classes
- properties: variables attached to classes
- supports inheritance

class Person {
	name = 'Max' #Property
	call = () => {...} #Method
}

const myPerson = new Person()
myPerson.call()
console.log(myPerson.name)

class Person extends Master

----
class Human {
	gender = 'male';

	printGender = () => {
	console.log(this.gender);
	}
}
class Person extends Human {
	name = 'Max';
	gender = 'female';

	printMyName = () => {
	console.log(this.name);
	}
}

const person = new Person();
person.printMyName();
person.printGender();
----

PROPERTIES

ES6
constructor() {
	this.myProperty = 'value'
}

ES7
myProperty = 'value'

----

METHODS

ES6
myMethod() {...}

ES7
myMethod = () => {...}


--------
OPERATORS:
- ...
- Spread: used to split up array elements OR object properties
const newArray = [...oldArray, 1, 2]
const newObject = {...oldObject, newProp:5}

- Rest: used to merge a list of function arguments into an array
function sortArgs(...args) {
	return args.sort()
}

----

const numbers = [1,2,3];
const newNumbers = [...numbers, 4];

console.log(newNumbers);

const person = {
	name: 'Max'
};

const newPersons = {
	...person,
	mood: 'happy'
}

console.log(newPerson);

const filter = (...args) => {
	return args.filter(el => el === 1);
}

console.log(filter(1, 2, 3));
--------
DESTRUCTURING
- Easily extract array elements or object properties and store them in variables
- Array Destructuring:
[a, b] = ['Hello', 'Max']
console.log(a) // Hello
console.log(b) // Max

- Object Destructuring:
{name} = {name:'Max', mood:'happy'}
console.log(name) // Max
console.log(mood) // undefined

----
const number = [1, 2, 3];
[num1, num2] = numbers;
console.log(num1, num2); // 1 2

[num1, , num3] = numbers;
console.log(num1, num3); // 1 3
--------
REFERENCE AND PRIMITIVE TYPES

Primitive types:
- numbers, strings, booleans
- they copy the values

const number = 1; //primitive type
const num2 = number; //copies the values

console.log(num2);

Reference types:
- objects, arrays
- whereas primitive types are stored in memory, reference types store a pointer to that place in memory

----
REFERENCE

const person = {
	name: 'Max'
}

const secondPerson = person;

person.name = 'Manu';

console.log(secondPerson);

----
REAL COPY

const person = {
	name: 'Max'
}

const secondPerson = {
	...person
};

person.name = 'Manu';

console.log(secondPerson);
--------
ARRAY FUNCTIONS

const numbers = [1, 2, 3];

const doubleNumArray = numbers.map((num) => {
	return num * 2;
});

console.log(numbers);
console.log(doubleNumArray);
--------


BASE SYNTAX
--------

linting - tool reminds you if you are writing suboptimal code

npm or yarn - dependency management

bundler(ex: webpack) - write module code and split up over multiple files. This code gets bundled into only a couple of files when we ship it
- helps import css into js files

babel + presets - compile code to run on as many browsers as possible

development server - webserver running on our machine to test code

register service worker: pre-cache script files

react component always has to render some html code to the dom

JSX:
- code used to write html but is not actual html
- etiquette says to nest everything in one root

In it's simplest form a Component is just a function that returns some JSX (some html)

PROPS
- props (properties) are the attributes you add onto your component
- they're set and passed from outside

when using class-based components, it's this.props

class PErson extends Component {
	render() {
	return <p>My name is {this.props}</p>;
	}
}

State:
- change your component at runtime
- state is managed from inside the component
- should be used with care (can make app unpredictable and hard to manage as it grows)
- updating state also updates props

Stateless Components (dumb components OR presentational components)
- have no internal state management
It is good practice to use stateless components as much as possible (makes app easier to maintain and manage)

Stateful Components (smart components OR container components)
- have internal state management
- only use state in a few select components

Method:
- a function of a class

Dont add function brackets to method in onclick b/c will immediately execute the function once react renders the component to the dom. Instead pass a Reference

// v THIS CAN BE INEFFICIENT WHEN SCALING PROJECT
onClick={() => this.switchNameHandler('Jeff!!')}

 MAY WANT TO USE v
 click={this.switchNameHandler.bind(this, "Jefferey!")}>

----
testMethod = () => {
	//using this type of method ensures that using 'this' always refers to the current class we're in

	this.setState({
	someState: 'some value'
	})    
}

Hook
- can manage state in functional components

--------
LISTS & CONDITIONALS

output content conditionally using javascript with ternary expression or better yet create variables

map operation - use on arrays to map objects or strings, etc into array of jsx elements and react will out these elements out and render to screen

add key to let react efficient update
--------
STYLING

Radium package
- lets us use inline styles with pseudo selectors and media queries
- wrap entire app in root component with StyleRoot so you can access radium functionality

export default Radium(App);
- this called a higher order component
- it's just a component wrapping another component adding extra functionality

Media queries can be used to check many things, such as:
- width and height of the viewport
- width and height of the device
- orientation (is the tablet/phone in landscape or portrait mode?)
- resolution

----

Styled components library
- making styled components very simple

backticks templates
- vanilla javascript feature
- used to define template literals
	- template literals are used to make strings easier
	- can interpolate any kind of expression in the template literal
	- can be multi-line

const Button = styled.button``
- function call that takes what text you pass it as styling for the button

----

npm run eject
- will eject from the under the hood configuration where you dont have access to the underlying web packed confile file, etc and gives you access

----
css modules feature

config/webpack.config.dev.js
config/webpack.config.prod.js

modules: true,
localIdentName: '[name]__[local]__[hash:base64:5]'

app.js

import classes from './App.css'

<div className={classes.App}>

^^^^^^
This css modules feature detects the import from the css file and understand not to just import the css as it is and instead look into the css and transforms every class name in a random unique class and returns a map mapped to the class names we choose
----
react-scripts 2 and higher you must vv

you can save the eject step and just

import classes from './Person.modules.css';
rename to Person.modules.css
--------
DEBUGGING
always check line number
use dev tool debugger
- source maps
- breakpoints and steps (in and outs)

use the React extension to get insight into app

----

StrictMode
- a tool for highlighting potential problems in an application
 - Strict mode checks are run in development mode only; they do not impact the production build

StrictMode currently helps with:
- Identifying components with unsafe lifecycles
- Warning about legacy string ref API usage
- Warning about deprecated findDOMNode usage
- Detecting unexpected side effects
- Detecting legacy context API
- Ensuring reusable state

----

ErrorBoundary component
- only use for cases that you know might fail and you know you can't control

componentDidCatch
- will be executed whenever a component we wrap with the ErrorBoundary throw an error
--------
COMPONENT DEEP DIVE

the render method should be lean and not contain too much jsx

containers
- manages the state
- manipulates the state

----
Stateful vs Stateless

stateless (dumb components)
- historically have always been functional components
- since React 16.8 functional components can manage state with useState hook

by splitting app into container components and dumb components you can keep your app manageable

----
(Use if you need to manage State or access to Lifecycle Hooks and don't want to use React Hooks)

Class-based
class XY extends Component
- access to state
- lifecycle hooks
access state and props via "this"
this.state.XY & this.props.XY
----
(Use in all other Cases)
Functional
const XY = prop => {...}
- access to state(useState())
X (NOT SUPPORTED YET) lifecycle hooks
props.XY
----

Component Lifecycle Methods or Component Lifecycle Hook
- Only available in Class-based Components

constructor()
getDerivedStateFromProps()
getSnapshotBeforeUpdate()
componentDidCatch()
componentWillUnmount()
shouldComponentUpdate()
componentDidUpdate()
componentDidMount()
render()

(Lifecycle Hooks have nothing to do with React Hooks)

Component Lifecycle - CREATION

constructor(props)
- Default ES6 class Feature
- Call super(props)
 - basically executes the contructor of the component you're extending (important so that everything get initialized correctly)
- DO: Set up State
- DONT: Cause Side-Effects
 - by side-effect it means sending http request, storing something in local browser storage, or sending analytics to google
 - this will impact performance and cause unnecessary re-renders

					|
					v
getDerivedStateFromProps(props,state)
- when ever your props change or class-based component you can sync your state to them
- DO: Sync state
- DONT: Cause Side-Effects

					|
					v
render()
- Prepare & Structure JSX code
- DO: Layout JSX and render html code
- DONT:
 - send http request or set any timeouts
 - nothing that will block the rendering process

					|
					v
Render Child Components

					|
					v
componentDidMount()
- DO: Cause Side-Effects
 - here you can make http requests
- DONT: Update State (triggers re-render)
 - dont update state here unless it's in a then block of a promise
 - dont call set state in here synchronously
----
Component Lifecycle - UPDATE

getDerivedStateFromProps(props,state)
- used to initialize the state of a component that updates based on props you're getting
- maybe some form control that gets external properties and want to interally handle user input
- DO: Sync State to Props
- DONT: Cause Side-Effects

					|
					v
shouldComponentUpdate(nextProps, nextState)
- May cancel updating process
- DO: Decide whether to Continue or Not
- DONT: Cause Side-Effects
- For performance optimization
- use carefully
- does a shallow comparison
 - as in for example arrays it compares the pointers not what the array is pointing to

					|
					v
render()
- Prepare & Structor JSX Code

					|
					v
Update Child Component Props

					|
					v
getSnapshotBeforeUpdate(prevProps, prevState)
 - use to save some data before the update and use it in the update
- DO: Last-minute DOM operations
 - like getting the current scrolling position of user
- DONT: Cause Side-Effects

					|
					v
componentDidUpdate()
- Most commonly used component
- DO: Cause Side-Effects
 - make http requests
- DONT: Update State (triggers re-render)
- don't update the state synchronously
- careful not to get caught in infinite loop here (ex when making http request and updating component)
----

Most important hooks
componentDidMount()
- typically fetching data from a server
componentDidUpdate()
- typically fetching data from a server
shouldComponentUpdate()
- for performance improvements

----

useEffect
- second most important next to useState
- basically combines the functionality or the use cases of all class-based lifecycle hook in one react hook
- not a lifecycle hook
- this is a React hook so you can add it into components
- can send http requests
- runs when component is created as well
takes a function that will run every render cycle


cleanup work
componentWillUnmount
- code run right before component is removed

useEffect cleanup
- can be ran when the component get destroyed (empty argument [] , or on every update (no argument), or pass an array that list all the data to watch and only when that data changes does it run the function useEffect then run the cleanup function

below we are cleaning up when the component is destroyed (an empyty array is passed)

useEffect(() => {
	console.log('[test.js useEffect');

	//this function is run before the main useEffect function runs but after the (first) render cycle
	return () => {
		console.log('[test.js] cleanup work in useEffect')
	}
}, []);

----

React.memo();

memoization
- technique where React will store a snapshot of this component and only if its input changes, it will re-render it and otherwise if its input do not change react will give back the stored component
- great way of getting optimization for functional components

----

PureComponent
- just a normal component that already implements shouldComponentUpdate with a complete props check that check for any changes for any prop in that component

----

How React Updates the (Real) DOM (the DOM in the browser)

render() is called
- render is like a suggestion of what the HTML should look like in the end, it can show what is already displayed
- this also applies to functional components and the JSX returned there, NOT just class-based components
- use shouldComponentUpdate() to prevent unnecessary render calls

Old Virtual DOM
<div>...<div>
- Faster than the "real" DOM
- it's simply a DOM representation in Javascript

Re-render Virtual DOM
<div>...<div>
- created when the render() method is called
- render() doesn't immediately update the "real" DOM!

It compares the old virtual DOM to the new one and checks if there are any differences
- if there are differences it reaches to the real DOM and updates it and only changes the places where difference were detected
- if no differences were found, then it doesn't touch the real DOM

accessing the DOM is really slow, it's something you want to do as little as possible

----

adjacent jsx elements

return [
	<p key='i1'>Hello</p>,
	<p key='i2'>I Am Adjacent</p>,
	<input key='i3' type="text"/>
];

Auxillary components
- used as a wrapper in cases where you want adjacentelements without extra DOM element being rendered
- HOC (higher order component)

aux.js
const aux = props => props.children;
export default aux;

props.children
- simply outputs whatever gets entered between the opening and closing tag this component

React.Fragment
- does the same thing as the Aux component

----

HOC
- Higher Order Component
- component that wraps other components that adds something to it (styling, additional HTML structure, or some logic)

----

passing unknown props

return props => (
    <div className={className}>
        <WrappedComponent {...props} />
    </div>
);
- the spread operator pull out all the properties that  are inside of this props object and distributes them as new key-value pairs on the wrapped component

--------
EXTRA STUFF

VS Code multi-line comment
Ctrl + / - will comment out all the lines with single line comments
Alt + Shift + A - will comment out all the lines with mult-line comments

Static methods
- static methods are often utility functions, such as functions to create or clone objects, whereas static properties are useful for caches, fixed-configuration, or any other data you don't need to be replicated across instances.

class Car {
	constructor(name) {
		this.name = name;
	}
	static hello() {
		return "Hello!!";
	}
}

let myCar = new Car("Ford");

// You can call 'hello()' on the Car Class:
document.getElementById("demo").innerHTML = Car.hello();

// But NOT on a Car Object:
// document.getElementById("demo").innerHTML = myCar.hello();
// this will raise an error. 
----
class Car {
  constructor(name) {
    this.name = name;
  }
  static hello(x) {
    return "Hello " + x.name;
  }
}
let myCar = new Car("Ford");
document.getElementById("demo").innerHTML = Car.hello(myCar); 

----

