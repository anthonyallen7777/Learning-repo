

(+ 2 (* 3 4) (- (+ 1 2) 3))
b/c starts with primitive = this expression is called a "call to a primitive"

the "+" is called an operator
the "2", "(* 3 4)", "(- (+ 1 2) 3)" are called operands

To evaluate a primitive call:
- first reduce operands to values
- then apply primitive to the values

Intuitively:
- left to right
- inside to outside

predicates are primitives or functions that produce a boolean value (true or false)
----

Natural number = all positive whole numbers except 0
Whole number = all positive counting numbers, plus 0
Integer = all whole numbers, plus their opposites (-1, -2), plus 0
Rational number = any number that can be expressed as a fraction of two integers
Irrational number = all numbers that can't be expressed as a fraction of two integers (pi, sqrt(7)) (non-repeating or non-terminating decimal)

----

HtDF Recipe
How to Design Functions
1. Signature, purpose and stub
2. Define examples, wrap each in check-expect
3. Template and inventory
4. Code the function body
5. Test and debug until correct

----

Signature:
Type ... -> Type
type of data the function consumes and produces
Primitive types are: Number, Integer, Natural, String, Image, Boolean

Purpose:
1 line description of what the function produces in terms of what it consumes

Stub is a function definition that:
- has correct function name
- has correct number of parameters
- produces dummy result of correct type

Examples/tests:
- examples help us understand what the function must do.
- multiple examples illustrate behavior
- wrapping in check-expect means they will also serve as unit tests for the completed function

Template:
the body of the template is the outline of the function

Code function body:
Use everything written before to know how to complete the function body
- sometimes helps to elaborate examples to show how the expected value could have been produced

---------

HtDD

problem domain					program
information-(represents)-------->data
     ^------------(interpret)------|


type comment:
-defines a new type name
-shows how to form data of that type

template:
-skeleton for on-argument functions that consume data of this type

Data defintion describes:
-how to form data of a new type
-how to represent information as data
-how to interpret data as information
-template for operating on data

Data definition simplifies function:
-restricts data consumed
-restricts data produced
-helps generate examples
-provides template

Atomic data:
- can't be taken apart into pieces that are meaningfully part of the same problem domain

Data definition consists of four or five parts:
1. A possible structure definition
2. A type comment that defines a new type name and describes how to form data
3. An interpretation that describes the correspondence between information and data
4. One or more examples of the data
5. A Template for a 1 argument function operating on data of this type